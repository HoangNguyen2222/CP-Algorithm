	Tháng 3: Dynamic Programming (Quy hoạch động)

- Buổi 1: Introduce and classical problems
- Buổi 2: Practice problems
- Buổi 3: Practice problems (level 1)
- Buổi 4: Practice problems (level 2)
- Buổi 5: Practice problems (level 3)
- Buổi 6: Change state in DP
- Buổi 7: Practice change state in DP
- Buổi 8: Contest

-----------------------------------------------------------------------------------------------------------------------------------------
			
					BUỔI 1

Quy hoạch động là gì ???????

Xét bài toán tính số fibonacci

Dãy số fibonacci là một dãy số được định nghĩa như sau: 

F(0) = 0
F(1) = 1
F(N) = F(N - 1) + F(N - 2) với mọi N > 1

Một vài số trong dãy fibonacci:

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,...

Cho số N, hãy tính fibonacci thứ N ????

Ta giải bài toán tính số fibonacci bằng chia để trị 

Định nghĩa F(N) là hàm tính số fibonacci thứ N

Nếu N == 0 thì return 0
Nếu N == 1 thì return 1
return F(N - 1) + F(N - 2)


#include <iostream>
using namespace std;

long long fibonacci(int n) {
	if (n == 0) {
		return 0;
	}
	if (n == 1) {
		return 1;
	}
	return fibonacci(n - 1) + fibonacci(n - 2);
}
 
int main () { 
	int n;
	cin >> n;
	cout << fibonacci(n) << endl;
	return 0;
} 


==========> ta sử dụng một bảng phương án nhằm mục đích lưu trữ những kết quả đã được tính rồi

Khi ta gọi đệ quy, nếu gặp đáp án đã được tính sẵn, ta chỉ việc gọi đáp án trong bảng phương án ra và gán lại kết quả vào bài toán.

===> phướng pháp sử dụng 1 bảng phương án nhằm lưu trữ những kết quả đã được tính sẵn, ta gọi đó là quy hoạch động.

#include <iostream>
int n;
long long F[105];

long long fibonacci(int n) {
	if (F[n] != -1) {
	    return F[n];
	}
	if (n == 0) {
		return F[0] = 0;
	}
	if (n == 1) {
		return F[1] = 1;
	}
	F[n] = fibonacci(n - 1) + fibonacci(n - 2);
	return F[n];
}
 
int main () { 
	cin >> n;
	for (int i = 0; i <= n; i++) {
 	    F[i] = -1;			// gán tất cả các phần tử trong F bằng -1
	}
	cout << fibonacci(n) << endl;
	return 0;
} 



		Ta có 2 cách code quy hoạch động:

Top down: Ta gọi hàm đệ quy từ bài toán lớn nhất, sau đó ta gọi đệ quy đến những bài toán con nhỏ hơn, và thực hiện tính toán lời giải 
dựa vô lời giải của những bài toán con nhỏ hơn đó.
	Ví dụ: 

#include <iostream>
int n;
long long F[105];

long long fibonacci(int n) {
	if (F[n] != -1) {
	    return F[n];
	}
	if (n == 0) {
		return F[0] = 0;
	}
	if (n == 1) {
		return F[1] = 1;
	}
	F[n] = fibonacci(n - 1) + fibonacci(n - 2);
	return F[n];
}
 
int main () { 
	cin >> n;
	for (int i = 0; i <= n; i++) {
 	    F[i] = -1;			// gán tất cả các phần tử trong F bằng -1
	}
	cout << fibonacci(n) << endl;
	return 0;
} 


Bottom up: Ta xây dựng lời giải cho những bài toán cơ sở, sau đó thực hiện tính toán lớn hơn dựa vào lời giải của những bài toán nhỏ hơn.
	ví dụ: 

#include <iostream>
using namespace std;
int n;
long long F[105];

void bottomUp(int n) {
	F[0] = 0;
	F[1] = 1;
	for (int i = 2; i <= n; i++) {
		F[i] = F[i - 1] + F[i - 2];
	}
	cout << F[n];
} 
int main () { 
	cin >> n;
	bottomUp(n);
	return 0;
} 


4 bước giải 1 bài toán quy hoạch động:

- Bước 1: Ta định nghĩa bài toán con với ý nghĩa là gì và ý nghĩa của các tham số truyền vào    //bước quan trọng nhất 
- Bước 2: Ta giải quyết những bài toán con ở trường hợp bài toán cơ sở
- Bước 3: Đưa ra kết quả bài toán
- Bước 4: Thực hiện giải quyết bài toán hiện tại dựa vào lời giải của những bài toán nhỏ hơn. Tips: Hãy giả sử mọi bài toán con đã được 
tính 1 cách tối ưu, hãy giải quyết bài toán hiện tại bằng lời giải bài toán con nhỏ hơn như thế nào ????


					------------------------------------------------------

Con ếch: https://atcoder.jp/contests/dp/tasks/dp_a

Nhận xét: Đây là bài toán giải quyết việc con ếch nhảy từ cột 1 đến cột N, ta có thể giải quyết bài toán con ếch nhảy từ cột 1 -> cột i 

- Gọi f[i] là tổng mức năng lượng nhỏ nhất để ếch có thể nhảy từ cột 1 -> cột i
- Bài toán cơ sở: f[1] = 0, f[2] = |h[2] - h[1]| 
- Đáp án bài toán: f[n]
- Công thức quy hoạch động: Ta cần tình f[i]
   + Nếu trước đó, ếch ở cột i - 1: f[i] = f[i - 1] + |h[i] - h[i - 1]|
   + Nếu trước đó, ếch ở cột i - 2: f[i] = f[i - 2] + |h[i] - h[i - 2]|

   f[i] = min(f[i - 1] + |h[i] - h[i - 1]|, f[i - 2] + |h[i] - h[i - 2]|)


	Lời giải: 

#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;

int frog(int n, int h[], int f[]) {
	f[1] = 0;
	f[2] = abs(h[2] - h[1]);
	for (int i = 3; i <= n; i++) {
		f[i] = min(f[i - 1] + abs(h[i] - h[i - 1]), f[i - 2] + abs(h[i] - h[i - 2]));
	}
	return f[n];
}

int main () { 
	int n;
	cin >> n;
	int height[100005];
	int f[100005];
	for (int i = 1; i <= n; i++) {
		cin >> height[i];
	}
	cout << frog(n, height, f) << endl;
	return 0;
} 

	
	Giải thích: 

Input: 6
       30 10 60 10 60 50
Output: 40



cin >> n; 		// Nhập n = 6
cin >> height[i];       // Nhập 30 10 60 10 60 50

f[1] = 0;
f[2] = abs(h[2] - h[1]) // f[2] = |10 - 30| = 20 

for (int i = 3; i <= n; i++) {
   f[i] = min(f[i - 1] + abs(h[i] - h[i - 1]), f[i - 2] + abs(h[i] - h[i - 2]));
   /*  f[3] = min(f[2] + abs(h[3] - h[2]), f[1] + abs(h[3] - h[1]));
            = min(20 + 50, 0 + 30) = 30
       
       f[4] = min(f[3] + abs(h[4] - h[3]), f[2] + abs(h[4] - h[2]));
            = min(30 + 50, 20 + 0) = 20

       f[5] = min(f[4] + abs(h[5] - h[4]), f[3] + abs(h[5] - h[3]));
            = min(20 + 50, 30 + 0) = 30
        
       f[6] = min(f[5] + abs(h[6] - h[5]), f[4] + abs(h[6] - h[4]));
            = min(30 + 10, 20 + 40) = 40
   */ 
}

return f[n];            // Xuất f[6] = 40


					------------------------------------------------------

Dãy con tăng dài nhất (bản dễ): https://oj.vnoi.info/problem/liq

Cho một dãy số nguyên dương a gồm N số. Hãy chọn ra 1 dãy con không liên tục sao cho các phần tử được chọn phải tăng dần và đội dài của 
dãy là lớn nhất có thể. Hỏi độ dài của dãy được chọn là bao nhiêu ???????

N = 10

a = [0, 5, 2, 9, 1, 1, 4, 8, 6, 3, 7]     // thêm số 0 vào đầu dãy

======> 4 ({1, 4, 6, 7})

{1, 4, 6, 7}

f[7] = 3

{2, 4, 8}, {1, 4, 8}

- Gọi f[i] là độ dài của dãy con tăng dài nhất khi chỉ có i phần tử đầu tiên và phần tử cuối cùng BẮT BUỘC phải là a[i]
- Bài toán cơ sở: f[0] = 0, a[0] = 0
- Đáp án bài toán: Giá trị lớn nhất của các f[i]
- Để tính f[i], ta cần tìm 1 vị trí j < i và a[j] < a[i]: f[i] = f[j] + 1

f[i] = max(f[i], f[j] + 1) với mọi j: 0 -> i - 1 và a[j] < a[i]

Độ phức tạp: O(N^2)


Lưu ý: Phải để biến n, a, f là biến toàn cục vì khi đó các phần tử trong mảng sẽ mặc định là 0, còn nếu để trong main thì mặc định sẽ là
các số rác trong mảng.

	Lời giải: 


#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
int n;
int a[1005];
int f[1005];
int longest(int n, int a[], int f[]) {
	a[0] = 0;
	f[0] = 0;
	int ans = -1;
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < i; j++) {
			if (a[j] < a[i]) {
				f[i] = max(f[i], f[j] + 1);
			}
		}
		ans = max(ans, f[i]);
	}
	return ans;
}
int main () { 
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	cout << longest(n, a, f) << endl;
	return 0;
} 


	Giải thích: 
Input: 6
       1 2 5 4 6 2
Output: 4


cin >> n;   				// Nhập n = 6
cin >> a[i];				// Nhập 1 2 5 4 6 2
a[0] = 0;				// gán thêm a[0] = 0
f[0] = 0;				// gán f[0] = 0

i = 1
  j = 0
    a[0] < a[1]         		// 0 < 1
       f[1] = max(f[1], f[0] + 1);      // f[1] = max(0, 1) = 1
ans = max(ans, f[1])			// ans = max(-1, 1) = 1  

i = 2
  j = 0
    a[0] < a[2]				// 0 < 2
       f[2] = max(f[2], f[0] + 1);	//f[2] = max(0, 1) = 1
  j = 1
    a[1] < a[2]
       f[2] = max(f[2], f[1] + 1); 	//f[2] = max(1, 2) = 2
ans = max(ans, f[2]) 			// ans = max(1, 2) = 2

i = 3
  j = 0
    a[0] < a[3]
       f[3] = max(f[3], f[0] + 1);      // f[3] = max(0, 1) = 1
  j = 1
    a[1] < a[3]
       f[3] = max(f[3], f[1] + 1); 	// f[3] = max(1, 2) = 2
  j = 2
    a[2] < a[3]
       f[3] = max(f[3], f[2] + 1); 	// f[3] = max(2, 3) = 3
ans = max(ans, f[3])			// ans = max(2, 3) = 3

i = 4
  j = 0
    a[0] < a[4]
       f[4] = max(f[4], f[0] + 1);	// f[4] = max(0, 1) = 1
  j = 1
    a[1] < a[4]
       f[4] = max(f[4], f[1] + 1); 	// f[4] = max(1, 2) = 2
  j = 2 
    a[2] < a[4]
       f[4] = max(f[4], f[2] + 1); 	// f[4] = max(2, 3) = 3
  j = 3
    a[3] > a[4]
ans = max(ans, f[4]);			// ans = max(3, 3) = 3

i = 5
  j = 0
    a[0] < a[5]
       f[5] = max(f[5], f[0] + 1); 	// f[5] = max(0, 1) = 1
  j = 1
    a[1] < a[5]
       f[5] = max(f[5], f[1] + 1); 	// f[5] = max(1, 2) = 2
  j = 2
    a[2] < a[5]
       f[5] = max(f[5], f[2] + 1); 	// f[5] = max(2, 3) = 3
  j = 3
    a[3] < a[5]
       f[5] = max(f[5], f[3] + 1); 	// f[5] = max(3, 4) = 4
  j = 4
    a[4] < a[5] 
       f[5] = max(f[5], f[4] + 1); 	// f[5] = max(4, 3 + 1) = 4
ans = max(ans, f[5]) 			// ans = max(3, 4) = 4

i = 6
 j = 0
    a[0] < a[6]
       f[6] = max(f[6], f[0] + 1);       // f[6] = max(0, 1) = 1
 j = 1
    a[1] = a[6]
 j = 2
    a[2] > a[6]
 j = 3
    a[3] > a[6]
 j = 4
    a[4] > a[6]
 j = 5
    a[5] > a[6]
ans = max(ans, f[6) 			// ans = max(4, 1) = 4       

return ans;				// Xuất 4 
  
  			
					------------------------------------------------------

Longest Common Subsequence: https://vjudge.net/problem/UVA-10405

Cho 2 chuỗi ký tự a và b. Hãy chọn một chuỗi con không liên tục trong chuỗi a và một chuỗi con không liên tục trong chuỗi b sao cho 
2 chuỗi này giống nhau và độ dài của chuỗi chung là lớn nhất có thể.

a = "aabdccaba"
b = "ccabdaac"

====> 5  	//chọn abdaa

aabd
ccabd

f[4][5] = 3 	// abd

- Gọi f[i][j] là độ dài lớn nhất của chuỗi chung khi chuỗi a có i ký tự ban đầu, chuỗi b có j ký tự ban đầu
- Bài toán cơ sở: f[i][0] = 0 , f[0][j] = 0 
- Đáp án bài toán: f[a.size()][b.size()]
- Công thức quy hoạch động: f[i][j] = ???
    + Nếu a[i] khác b[j]: f[i][j] = max(f[i - 1][j], f[i][j - 1])
         ví dụ: 
                aabdc	// a[5] = c
                ccabd   // b[5] = d
         ---> aabd vs ccabd	//f[4][5]
         ---> aabdc vs ccab	// f[5][4]
         ==> f[5][5] = max(f[4][5], f[5][4])

    + Nếu a[i - 1] bằng b[j - 1]: 
       . Ta chấp nhận ký tự c = a[i - 1] = b[j - 1] là ký tự trong chuỗi chung: f[i][j] = f[i - 1][j - 1] + 1
         ví dụ: 
                 aabd  // a[4] = d
                 ccabd // b[5] = d
              ---> f[4][5] = f[3][4] + 1

       . Ta có thể không chấp nhận ký tự này vào chuỗi chung: f[i][j] = max(f[i - 1][j], f[i][j - 1])

   f[i][j] = max(f[i - 1][j - 1] + 1, f[i - 1][j], f[i][j - 1])

Lưu ý: Chuỗi a và b có thể có ký tự khoảng trắng !!!!!!  

Khi ta đọc chuỗi a và b trên 1 dòng, hãy dùng lệnh getline


	Lời giải: 

#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
string a, b;
int f[1005][1005];

int longestCommonSub(string a, string b, int f[1005][1005]) {
	memset(f, 0, sizeof(f));
	for (int i = 0; i <= (int)a.size(); i++) {
		f[i][0] = 0;
	}
	for (int j = 0; j <= (int)b.size(); j++) {
		f[0][j] = 0;
	}
	for (int i = 1; i <= (int)a.size(); i++) {
		for (int j = 1; j <= (int)b.size(); j++) {
			f[i][j] = max(f[i - 1][j], f[i][j - 1]);
			if (a[i - 1] == b[j - 1]) {
				f[i][j] = max(f[i - 1][j - 1] + 1, f[i][j]);
			}
		}
	}
	return f[(int)a.size()][(int)b.size()];
	
} 

int main () { 
	while (getline(cin, a)) {
		getline(cin, b);
		cout << longestCommonSub(a, b, f) << endl;
	}	
	return 0;
} 

				         ------------------------------------------------------

Vacation: https://atcoder.jp/contests/dp/tasks/dp_c

Một kỳ nghỉ có N ngày nghỉ. Mỗi ngày nghỉ có thể chơi 1 trong 3 trò chơi A, B hoặc C. Nếu ngày thứ i ta chơi trò A, ta sẽ có độ hạnh phúc
là a[i], ngày i chơi trò B thì sẽ có độ hạnh phúc là b[i], ngày i chơi trò C ta sẽ có độ hạnh phúc là c[i]

Ta hãy chơi toàn bộ N ngày nghỉ sao cho không có 2 ngày nghỉ liên tục chơi trò chơi giống nhau và tổng độ hạnh phúc lớn nhất có thể.

N = 4

3 5 5 
7 8 1 
4 3 9
2 8 1

Ngày 1: C
Ngày 2: B
Ngày 3: C
Ngày 4: B

- Gọi f[i][state] là tổng độ hạnh phúc lớn nhất khi ta có i ngày nghỉ đầu tiên 
   + state = 0: ta BUỘC ngày i phải chơi trò A
   + state = 1: ta BUỘC ngày i phải chơi trò B
   + state = 2: ta BUỘC ngày i phải chơi trò C
- Bài toán cơ sở: 
  f[1][0] = a[1], f[1][1] = b[1], f[1][2] = c[1]
- Đáp án bài toán: 
  max(f[n][0], f[n][1], f[n][2])
- Công thức quy hoạch động: 
   f[i][0] = max(f[i - 1][1] + a[i], f[i - 1][2] + a[i])
   f[i][1] = max(f[i - 1][0] + b[i], f[i - 1][2] + b[i])
   f[i][2] = max(f[i - 1][0] + c[i], f[i - 1][1] + c[i])

  
	Lời giải: 
  
#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
int n;
int f[100005][3];
int a[100005], b[100005], c[100005];
int main () { 
	cin >> n;
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		cin >> a[i] >> b[i] >> c[i];
	}
        f[1][0] = a[1];
	f[1][1] = b[1];
	f[1][2] = c[1];
	for (int i = 2; i <= n; i++) {
		f[i][0] = max(f[i - 1][1], f[i - 1][2]) + a[i];
		f[i][1] = max(f[i - 1][0], f[i - 1][2]) + b[i];
		f[i][2] = max(f[i - 1][0], f[i - 1][1]) + c[i];
	}
	ans = max(f[n][0], max(f[n][1], f[n][2]));
	cout << ans << endl;
	return 0;
} 


	Giải thích: 
Input: 3
       10 40 70
       20 50 80
       30 60 90
Output: 210

f[1][0] = 10;
f[1][1] = 40;
f[1][2] = 70;

i = 2
  f[2][0] = max(f[1][1], f[1][2]) + a[2] = 70 + 20 = 90
  f[2][1] = max(f[1][0], f[1][2]) + b[2] = max(10, 70) + 50 = 120
  f[2][2] = max(f[1][0], f[1][1]) + c[2] = max(10, 40) + 80 = 120
i = 3
  f[3][0] = max(f[2][1], f[2][2]) + a[3] = 150
  f[3][1] = max(f[2][0], f[2][2]) + b[3] = 200
  f[3][2] = max(f[2][0], f[2][1]) + c[3] = 210

ans = max(f[3][0], f[3][1], f[3][2]) = 210 		// Xuất 210

				
					------------------------------------------------------

Knapsack 1: https://atcoder.jp/contests/dp/tasks/dp_d

Một ngôi nhà có N đồ vật. Đồ vật thứ i sẽ có trọng lượng là w[i] và có giá tiền là c[i]. Một người ăn trộm vào ngôi nhà và mang theo 
1 cái túi có tải trọng M. Hỏi người ăn trộm cần bỏ những đồ vật nào vào cái túi sao cho tổng khối lượng đồ vật trong túi không vượt quá 
M và tổng giá tiền lớn nhất có thể ? 

N = 8, M = 15

4 8   x
2 6   x
14 30 
4 7   x
1 1
3 5
2 5   x 
3 9   x

=========> 8 + 6 + 7 + 5 + 9 = 35

1 <= N <= 100
1 <= M <= 100000

Bài toán lớn nhất đang là bài toán đi vào ngôi nhà có N đồ vật và dùng cái túi có tải trọng M 

- Gọi f[i][j] là tổng số tiền lớn nhất ta có thể bán được nếu ta bước vào căn nhà có i đồ vật và cái túi có tải trọng là j
- Bài toán cơ sở: f[0][j] = 0, f[i][0] = 0
- Kết quả bài toán: f[N][M]
- Công thức quy hoạch động: 
    Ta cần tình f[i][j]
  Tình huống 1: Ta không lấy đồ vật thứ i: f[i][j] = f[i - 1][j]
  Tình huống 2: Ta chấp nhận lấy đồ vật thứ i (j >= w[i]): f[i][j] = f[i - 1][j - w[i]] + c[i]
 
  f[i][j] = f[i - 1][j]
  nếu j >= w[i]: f[i][j] = max(f[i][j], f[i - 1][j - w[i]] + c[i])


	Lời giải: 

#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;

int n, w;
int weight[105];
int dollar[105];
long long f[105][100005];

int main () { 
	cin >> n >> w;
	for (int i = 1; i <= n; i++) {
		cin >> weight[i] >> dollar[i];
	}
	memset(f, 0, sizeof(f));
	for (int j = 1; j <= w; j++) {
		f[0][j] = 0;
	}
	for (int i = 1; i <= n; i++) {
		f[i][0] = 0;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= w; j++) {
			f[i][j] = f[i - 1][j];
			if (j >= weight[i]) {
				f[i][j] = max(f[i][j], f[i - 1][j - weight[i]] + dollar[i]);
			}
		}
	}
	cout << f[n][w] << endl;
	return 0;
} 


	Giải thích: 
Input:  3 8
	3 30
	4 50
	5 60
Output: 90

memset(f, 0, sizeof(f)); 				// Gán tất cả các phần tử trong f = 0;
for j: 1 -> w
    f[0][j] = 0;					// Bài toán cơ sở: f[0][j] = 0;
for i: 1 -> n
    f[i][0] = 0;					// Bài toán cơ sở: f[i][0] = 0;

for i: 1 -> n
  for j: 1 -> w
      // i = 1, j = 1
         f[1][1] = f[0][1] = 0;				// Trường hợp không thấy đồ vật thứ i = 1
         if (1 >= weight[1])				// 1 < 3

      // i = 1, j = 2
         f[1][2] = f[0][2] = 0;
         if (2 >= weight[1])				// 2 < 3

      // i = 1, j = 3
         f[1][3] = f[0][3] = 0;
         if (3 >= weight[1]) 				// 3 = 3
            f[1][3] = max(f[1][3], f[0][0] + 30) = 30;
     
      // i = 1, j = 4
         f[1][4] = f[0][4] = 0;
         if (4 >= weight[1]) 				// 4 > 3
            f[1][4] = max(f[1][4], f[0][1] + 30) = 30;
  
      // i = 1, j = 5
         f[1][5] = f[0][5] = 0;
         if(5 >= weight[1])
            f[1][5] = max(f[1][5], f[0][2] + 30) = 30;
 
      // i = 1, j = 6
         f[1][6] = f[0][6] = 0;
         if (6 >= weight[1]) 
            f[1][6] = max(f[1][6], f[0][3] + 30) = 30;
 
      // i = 1, j = 7					// tương tự --> f[1][7] = 30
      // i = 1, j = 8 					// tương tự --> f[1][8] = 30

      // i = 2, j = 1
         f[2][1] = f[1][1] = 0;
         if (1 >= weight[2])				// 1 < 4
  
      // i = 2, j = 2
         f[2][2] = f[1][2] = 0;
         if (2 >= weight[2])
     
      // i = 2, j = 3
         f[2][3] = f[1][3] = 30;
  	 if (3 >= weight[2]) 
  
      // i = 2, j = 4
         f[2][4] = f[1][4] = 30;
         if (4 >= weight[2])				// 4 = 4
            f[2][4] = max(f[2][4], f[1][0] + dollar[2]) // f[2][4] = 50
    
      // i = 2, j = 5
         f[2][5] = f[1][5] = 30;
         if (5 >= weight[2])
            f[2][5] = max(f[2][5], f[1][1] + 50) = 50; 
    
      // i = 2, j = 6
         f[2][6] = f[1][6] = 30; 
         if (6 >= weight[2])
            f[2][6] = max(f[2][6], f[1][2] + 50) = 50; 
 
      // i = 2, j = 7
         f[2][7] = f[1][7] = 30;
	 if (7 >= weight[2])
            f[2][7] = max(f[2][7], f[1][3] + 50) = 80;
   
      // i = 2, j = 8
         f[2][8] = f[1][8] = 30;
         if (8 >= weight[2])
            f[2][8] = max(f[2][8], f[1][4] + 50) = 80;
 
      // i = 3, j = 1
         f[3][1] = f[2][1] = 0;
         if (1 >= weight[3])				// 1 < 5

      // i = 3, j = 2
         f[3][2] = f[2][2] = 0;
         if (2 >= weight[3])
 
      // i = 3, j = 3
         f[3][3] = f[2][3] = 30; 
         if (3 >= weight[3])

      // i = 3, j = 4
         f[3][4] = f[2][4] = 50; 
         if (4 >= weight[3])

      // i = 3, j = 5
         f[3][5] = f[2][5] = 50;
         if (5 >= weight[3])				// 5 = 5
            f[3][5] = max(f[3][5], f[2][0] + 60) = 60; 

      // i = 3, j = 6
         f[3][6] = f[2][6] = 50;
         if (6 >= weight[3])
            f[3][6] = max(f[3][6], f[2][1] + 60) = 60;

      // i = 3, j = 7
         f[3][7] = f[2][7] = 80;
         if (7 >= weight[3])
            f[3][7] = max(f[3][7], f[2][2] + 60) = 80;

      // i = 3, j = 8
         f[3][8] = f[2][8] = 80;
         if (8 >= weight[3]) 
             f[3][8] = max(f[3][8], f[2][3] + 60) = max(80, 30 + 60) = 90;

      // Xuất 90.     
    

-----------------------------------------------------------------------------------------------------------------------------------------

		
						BUỔI 2


Minimizing Coins: https://cses.fi/problemset/task/1634

Ta có 1 bộ sưu tập tiền lẻ với N mệnh giá, mệnh giá thứ i là c[i]. Mỗi mệnh giá ta không giới hạn số lượng đồng tiền.

Cho 1 số tiền là S, hỏi cần dùng ít nhất bao nhiêu đồng tiền để có thể cho ra tổng = S ?????????
Xuất ra -1 nếu không tồn tại cách đổi tiền 

N = 5, S = 15

{3, 4, 9, 10, 6}

15 = 3 + 3 + 3 + 3 + 3
   = 3 + 3 + 3 + 6
   = 9 + 6

- Gọi f[i][j] là tổng số lượng đồng xu ít nhất khi có i mệnh giá và tổng tiền = j
- Bài toán cơ sở: f[0][0] = 0, f[i][j] = inf (dương vô cực)
- Đáp án bài toán: nếu f[N][S] == inf ===> xuất ra -1, ngược lại xuất ra f[N][S]
- Công thức quy hoạch động: 
   Tình huống 1: Ta không sử dụng mệnh giá thứ i: f[i][j] = f[i - 1][j]
   Tình huống 2: Ta dùng 1 đồng xu ở mệnh giá thứ i (điều  kiện j >= a[i])  
    f[i][j] = min(f[i][j - a[i]] + 1, f[i][j])

1 <= N <= 100
1 <= S <= 1000000

f rất lớn (f có 10^8 phần tử ======> memory limit) 

Nhận xét: f[i].. tính dựa trên f[i - 1]....

Ta tối ưu bảng f chiều i chỉ còn 0 và 1

Khởi tạo f[0][0] = 0

Ta tính f[1] dựa trên f[0]
Sau đó lại tiếp tục tính f[0] dựa trên f[1]
Lại tình f[1] dựa trên f[0]

N = 5, S = 6

{3, 4, 9}
 
f[0][0] = 0, f[0][1] = f[0][2] = f[0][3] = f[0][4] = f[0][5] = f[0][6] = inf
f[1][0] = 0, f[1][1] = inf, f[1][2] = ....
f[0][0] = 0  


	Lời giải: 

#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
const int inf = 1000000006;
int n, x;
int c[105];
int f[2][1000005];

int main () { 
	cin >> n >> x;
	for (int i = 1; i <= n; i++) {
		cin >> c[i];
	}	
	for (int j = 0; j <= x; j++) {
		f[0][j] = inf;
	}
	f[0][0] = 0;
	
	for (int i = 1; i <= n; i++) {
		int now = i % 2; 
		int prev = !now;
		for (int j = 0; j <= x; j++) {
			f[now][j] = inf;
		}
		for (int j = 0; j <= x; j++) {
			f[now][j] = min(f[now][j], f[prev][j]);
			if (j >= c[i]) {
				f[now][j] = min(f[now][j - c[i]] + 1,f[now][j]);
			}
		}
	}
	cout << (f[n % 2][x] == inf ? -1 : f[n % 2][x]) << endl;
	return 0;
} 


	Giải thích: 
Input:3 6
      4 3  9
Output: 2

f1: 0 inf inf inf 1 inf inf          Tổng quát
f0: 0 inf inf  1  1 inf 2
f1: 0 inf inf  1  1 inf 2


for j: 0 -> x
  f[0][0] = f[0][1] = f[0][2] = f[0][3] = f[0][4] = f[0][5] = f[0][6] = inf 

f[0][0] = 0;

for i: 1 -> n
   // i = 1
      now = 1;
      prev = 0;
      for j: 0 -> x
         f[1][0] = f[1][1] = f[1][2] = f[1][3] = f[1][4] = f[1][5] = f[1][6] = inf
      for j: 0 -> x
         // j = 0
            f[1][0] = min(f[1][0], f[0][0]) = 0
            if (0 >= c[1])								// 0 < 4
        
	 // j = 1
            f[1][1] = min(f[1][1], f[0][1]) = inf
 
         // j = 2
            f[1][2] = min(f[1][2], f[0][2]) = inf
 
   	 // j = 3
            f[1][3] = min(f[1][3], f[0][3]) = inf

         // j = 4
            f[1][4] = min(f[1][4], f[0][4]) = inf
            if (4 >= c[1])
               f[1][4] = min(f[1][4], f[1][0] + 1) = 1
          
         // j = 5
            f[1][5] = min(f[1][5], f[0][5]) = inf
            if (5 >= c[1])
               f[1][5] = min(f[1][5], f[1][1] + 1) = inf

         // j = 6
            f[1][6] = min(f[1][6], f[0][6]) = inf
            if (6 >= c[1])
               f[1][6] = min(f[1][6], f[1][2] + 1) = inf

   // i = 2
      now = 0;
      prev = 1; 
      for j: 0 -> x
        f[0][0] = f[0][1] = f[0][2] = f[0][3] = f[0][4] = f[0][5] = f[0][6] = inf
      for j: 0 -> x
        // j = 0
           f[0][0] = min(f[0][0], f[1][0]) = 0    
 
        // j = 1
           f[0][1] = min(f[0][1], f[1][1]) = inf

        // j = 2
           f[0][2] = min(f[0][2], f[1][2]) = inf

        // j = 3
           f[0][3] = min(f[0][3], f[1][3]) = inf
           if (3 >= c[2])
              f[0][3] = min(f[0][3], f[0][0] + 1) = 1

        // j = 4
           f[0][4] = min(f[0][4], f[1][4]) = 1
           if (4 >= c[2])
              f[0][4] = min(f[0][4], f[0][1] + 1) = 1

        // j = 5
           f[0][5] = min(f[0][5], f[1][5]) = inf
           if (5 >= c[2]) 
               f[0][5] = min(f[0][5], f[0][2] + 1) = inf

        // j = 6
           f[0][6] = min(f[0][6], f[1][6]) = inf
           if (6 >= c[2])
               f[0][6] = min(f[0][6], f[0][3] + 1) = 2

   // i = 3
      now = 1; 
      prev = 0;
      for j: 0 -> x
         f[1][0] = f[1][1] = f[1][2] = f[1][3] = f[1][4] = f[1][5] = f[1][6] = inf
      for j: 0 -> x
         // j = 0
            f[1][0] = min(f[1][0], f[0][0]) = 0
     
         // j = 1
            f[1][1] = min(f[1][1], f[0][1]) = inf
     
         // j = 2
            f[1][2] = min(f[1][2], f[0][2]) = inf

         // j = 3
            f[1][3] = min(f[1][3], f[0][3]) = 1

         // j = 4
            f[1][4] = min(f[1][4], f[0][4]) = 1

         // j = 5
            f[1][5] = min(f[1][5], f[0][5]) = inf
 
         // j = 6
            f[1][6] = min(f[1][6], f[0][6]) = 2

cout << (f[3 % 2][6] == inf ? -1 : f[3 % 2][6]) << endl;  			// Xuất 2
	

					------------------------------------------------------

Xếp hàng mua vé: https://oj.vnoi.info/problem/nktick


Dấu hiệu để nhận ra đây là bài toán quy hoạch động: Người 1 mua vé => người 2 => người 3 => người 4 => .....


- Gọi f[i] là tổng thời gian nhỏ nhất khi có i người muốn mua vé
- Bài toán cơ sở: f[0] = 0, khởi tạo các f[i] còn lại = inf
- Đáp án bài toán: f[N]
- Công thức quy hoạch động: 
   . Tình huống 1: Người thứ i mua vé cho chính họ: f[i] = f[i - 1] + t[i]
   . Tình huống 2: Người thứ i nhờ i - 1 mua vé giùm (i >= 2): f[i] = f[i - 2] + r[i - 1]

====> f[i] = min(f[i - 1] + t[i], f[i - 2] + r[i - 1])

	Lời giải: 

#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
const int inf = 1000000000;
int n;
int t[60006];
int r[60005];
int f[60005];
int main () { 
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> t[i];
	}
	for (int i = 1; i < n; i++) {
		cin >> r[i];
	}
	f[0] = 0;
	for (int i = 1; i <= n; i++) {
		f[i] = inf;
	}
 	
	for (int i = 1; i <= n; i++) {
		f[i] = f[i - 1] + t[i];
		if (i >= 2) {
			f[i] = min(f[i - 1] + t[i], f[i - 2] + r[i - 1]);
		}
	}
	cout << f[n] << endl;
	return 0;
}

	Giải thích: 
Input:  5
	2 5 7 8 4
	4 9 10 10
Output: 18

f[0] = 0;
for i: 1 -> n
    f[1] = f[2] = f[3] = f[4] = f[5] = inf

for i: 1 -> n
    // i = 1
       f[1] = f[0] + t[1] = 2

    // i = 2
       f[2] = f[1] + t[2] = 7
       if (i >= 2)
          f[2] = min(f[1] + t[2], f[0] + r[1]) = 4

    // i = 3
       f[3] = f[2] + t[3] = 11
       if (i >= 2)
          f[3] = min(f[2] + t[3], f[1] + r[2]) = 11 

    // i = 4
       f[4] = f[3] + t[4] = 19
       if (i >= 2) 
          f[4] = min(f[3] + t[4], f[2] + r[3]) = 14

    // i = 5
       f[5] = f[4] + t[5] = 18
       if (i >= 2)
          f[5] = min(f[4] + t[5], f[3] + r[4]) = 18

Xuất 18

					------------------------------------------------------

Ioipalin: https://www.spoj.com/problems/IOIPALIN/

Cho một chuỗi s gồm N ký tự. Hỏi cần thêm ít nhất bao nhiêu ký tự để s là chuỗi đối xứng.

s = "aabca" ===> thêm 2 chữ



- Gọi f[i][j] là số lượng ký tự ít nhất cần thêm vào để chuỗi gồm các ký tự từ [i...j] thành chuỗi đối xứng
- Bài toán cơ sở: Khi i == j: f[i][i] = 0, khởi tạo các f[i][j] còn lại bằng inf
- Đáp án bài toán: f[1][n]
- Công thức quy hoạch động: 
    nếu s[i] == s[j]: f[i][j] = f[i + 1][j - 1]
    nếu s[i] != s[j]: f[i][j] = min(f[i + 1][j] + 1, f[i][j - 1] + 1)

for i: n -> 1
  for j: i + 1 -> n
     nếu s[i] == s[j]
        f[i][j] = f[i + 1][j - 1]
     else 
        f[i][j] = min(f[i + 1][j] + 1, f[i][j - 1] + 1)

	Lời giải: 

#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
const int inf = 1000000000;
int n;
string s;
int f[5005][5005];
int main () { 
	cin >> n;
	cin >> s;
	for (int i = n - 1; i >= 1; i--) {
		for (int j = i + 1; j <= n; j++) {
			if (i == j) {
				f[i][j] = 0;
			} else {
				f[i][j] = inf;
			}
		}
	}
	for (int i = n - 1; i >= 1; i--) {
		for (int j = i + 1; j <= n; j++) {
			if (s[i - 1] == s[j - 1]) {
				f[i][j] = f[i + 1][j - 1];
			} else {
				f[i][j] = min(f[i + 1][j] + 1, f[i][j - 1] + 1);
			}
		}
	}
	cout << f[1][n] << endl;
	return 0;
}


	Giải thích: 
Input: 5
       Ab3bd
Output: 2

n = 5;
s = "Ab3bd"
for i: 1 -> n
   f[1][1] = f[2][2] = f[3][3] = f[4][4] = f[5][5] = 0;
for i: n - 1 -> 1
  for j: i + 1 -> n
     // i = 4, j = 5
        f[4][5] = inf
     // i = 3, j = 4
        f[3][4] = inf
     // i = 3, j = 5
        f[3][5] = inf
     // i = 2, j = 3
        f[2][3] = inf
     // i = 2, j = 4
        f[2][4] = inf
     // i = 2, j = 5
        f[2][5] = inf
     // i = 1, j = 2
        f[1][2] = inf
     // i = 1, j = 3
        f[1][3] = inf
     // i = 1, j = 4
        f[1][4] = inf
     // i = 1, j = 5
        f[1][5] = inf

for i: n - 1 -> 1
  for j: i + 1 -> n
     // i = 4, j = 5
        if (s[3] == s[4])						// b != d
        f[4][5] = min(f[5][5] + 1, f[4][4] + 1) = 1;
 
     // i = 3, j = 4
        if (s[2] == s[3])						// 3 != b
        f[3][4] = min(f[4][4] + 1, f[3][3] + 1) = 1;

     // i = 3, j = 5
        if (s[2] == s[4])
        f[3][5] = min(f[4][5] + 1, f[3][4] + 1) = 2;

     // i = 2, j = 3
        if (s[1] == s[2])
        f[2][3] = min(f[3][3] + 1, f[2][2] + 1) = 1;
 
     // i = 2, j = 4
        if (s[1] == s[3])
           f[2][4] = f[3][3] = 0;

     // i = 2, j = 5
        if (s[1] == s[4])
        f[2][5] = min(f[3][5] + 1, f[2][4] + 1) = 1;

     // i = 1, j = 2
        if (s[0] == s[1])
        f[1][2] = min(f[2][2] + 1, f[1][1] + 1) = 1;
 
     // i = 1, j = 3
        if (s[0] == s[2])
        f[1][3] = min(f[2][3] + 1, f[1][2] + 1) = 2;

     // i = 1, j = 4
        if (s[0] == s[3])
        f[1][4] = min(f[2][4] + 1, f[1][3] + 1) = 1;

     // i = 1, j = 5
        if (s[0] == s[4])
        f[1][5] = min(f[2][5] + 1, f[1][4] + 1) = 2;

Xuất f[1][5] = 2;

           
					------------------------------------------------------

Khuyến mãi: https://oj.vnoi.info/problem/c11km

Có N món hàng, món thứ i có giá p[i]. Nếu p[i] > 100 =========> khi ta mua món p[i] bằng tiền mặt thì ta được 1 thẻ khuyến mãi, thẻ này
có thể dùng để mua 1 món đồ nào sau đó mà hoàn toàn miễn phí. 

Ta muốn mua toàn bộ N món hàng, theo thứ tự món 1 -> món 2 -> .. -> món N, hỏi tổng tiền nhỏ nhất cần phải trả là bao nhiêu ???????

N = 7

p = [45, 23, 102, 2, 103, 40, 200]

----> 275

1 <= N <= 1000

f[4][0] = 170     // mua 45, 23, 102 bằng tiền mặt và dùng 1 thẻ khuyến mãi lấy 2
f[4][1] = 172     // mua 45, 23, 102, 2 bằng tiền mặt và sẽ có 1 thẻ khuyến mãi
f[5][0] = 172     // mua 45, 23, 102, 2 bằng tiền mặt và trả 103 bằng thẻ khuyến mãi
f[5][1] = 273     // mua 45, 23, 102 bằng tiền mặt và dùng 1 thẻ khuyến mãi lấy 2 và mua 103 bằng tiền mặt sẽ có 1 thẻ khuyến mãi

- Gọi f[i][j] là tổng tiền nhỏ nhất có thể khi có i món hàng và trong tay của ta đang có j thẻ khuyến mãi
- Bài toán cơ sở: f[0][0] = 0, f[i][j] còn lại = inf
- Đáp án bài toán: Duyệt j: 0 -> n, tìm min(f[n][j])
- Công thức quy hoạch động: 
  . Tình huống 1: p[i] <= 100
      + Mua p[i] bằng tiền mặt       : f[i][j] = f[i - 1][j] + p[i]
      + Dùng thẻ khuyến mãi cho p[i] : f[i][j] = f[i - 1][j + 1]
======> f[i][j] = min(f[i - 1][j] + p[i], f[i - 1][j + 1])
  . Tình huống 2: p[i] > 100
      + Mua p[i] bằng tiền mặt (j >= 1)	  : f[i][j] = f[i - 1][j - 1] + p[i]
      + Dùng thẻ khuyến mãi 	          : f[i][j] = f[i - 1][j + 1]
======> f[i][j] = min(f[i - 1][j - 1] + p[i], f[i - 1][j + 1])



- Giả sử ta đang đứng tại bài toán f[i][j] != inf  (f[i][j] đã có lời giải)
- Xét món thứ i + 1
  
  . Nếu p[i + 1] <= 100: 
      + Nếu ta mua p[i + 1] bằng tiền mặt               :  f[i + 1][j] = min(f[i + 1][j], f[i][j] + p[i + 1])
      + Nếu ta dùng thẻ khuyến mãi cho p[i + 1] (j > 0) :  f[i + 1][j - 1] = min(f[i + 1][j - 1], f[i][j])
  . Nếu p[i + 1] > 100: 
      + Nếu ta mua p[i + 1] bằng tiền mặt		:  f[i + 1][j + 1] = min(f[i + 1][j + 1], f[i][j] + p[i + 1])
      + Nếu ta dùng thẻ khuyến mãi cho p[i + 1] (j > 0) :  f[i + 1][j - 1] = min(f[i + 1][j - 1], f[i][j])


	Lời giải: 

#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
const int inf = 10000000;
int n;
int p[1004];
int f[1005][1005];

int main () { 
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> p[i];
	}
	for (int i = 0; i <= n + 3; i++) {
		for (int j = 0; j <= n + 3; j++) {
			f[i][j] = inf;
		}
	}
	f[0][0] = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= i; j++) {
			f[i][j] = f[i - 1][j + 1];
			if (p[i] <= 100) {
				f[i][j] = min(f[i - 1][j] + p[i], f[i][j]);
			} else if (p[i] > 100) {
				if (j >= 1) {
					f[i][j] = min(f[i][j], f[i - 1][j - 1] + p[i]);
				} 
			}	
		}
	}
	int ans = inf;
	for (int j = 0; j <= n; j++) {
		ans = min(ans, f[n][j]);
	}
	cout << ans << endl;
	return 0;
}


	Giải tay:

Input: 5
       35
       40
       101
       59
       63
Output: 235

f[1][0] = min(f[1 - 1][0] + p[1], f[1 - 1][0 + 1]) = min(35, inf) = 35
f[1][1] = min(f[1 - 1][1] + p[1], f[1 - 1][1 + 1]) = min(inf, inf) = inf
f[1][2] = min(f[0][2] + p[1], f[0][3]) = min(inf, inf) = inf
f[1][3] = min(f[0][3] + p[1], f[0][4]) = inf
f[1][4] = min(f[0][4] + p[1], f[0][5]) = inf
f[1][5] = min(f[0][5] + p[1], f[0][6]) = inf

f[2][0] = min(f[1][0] + p[2], f[1][1]) = min(75, inf) = 75
f[2][1] = min(f[1][1] + p[2], f[1][2]) = min(inf, inf) = inf
f[2][2] = min(f[1][2] + p[2], f[1][3]) = min(inf, inf) = inf
f[2][3] = min(f[1][3] + p[2], f[1][4]) = inf
f[2][4] = min(f[1][4] + p[2], f[1][5]) = inf
f[2][5] = min(f[1][5] + p[2], f[1][6]) = inf

f[3][0] = min(f[3][0], f[2][1]) = inf
f[3][1] = min(f[2][0] + p[3], f[2][2]) = min(176, inf) = 176
f[3][2] = min(f[2][1] + p[3], f[2][3]) = inf
f[3][3] = inf
f[3][4] = inf
f[3][5] = inf

f[4][0] = min(f[3][0] + p[4], f[3][1]) = 176
f[4][1] = min(f[3][1] + p[4], f[3][2]) = min(235, inf) = 235
f[4][2] = min(f[3][2] + p[4], f[3][3]) = inf
f[4][3] = inf
f[4][4] = inf
f[4][5] = inf

f[5][0] = min(f[4][0] + p[5], f[4][1]) = min(239, 235) = 235
f[5][1] = min(f[4][1] + p[5], f[4][2]) = min(298, inf) = 298
f[5][2] = min(f[4][2] + p[5], f[4][3]) = min(inf, inf) = inf
f[5][3] = inf
f[5][4] = inf
f[5][5] = inf


Xuất 235

					 ------------------------------------------------------


Đãi tiệc: https://vinhdinhcoder.net/Problem/Details/5043?fbclid=IwAR0VlWLCjsJQj5B22kq1n-6Rrtty5OPY79D9zkUZHxWRmcHqUTyCjSAr_Zw

ví dụ: 
6
22 89 12 56 90 43
 x   x    x   x  

4 257

- Gọi f[i] là tổng lượng nước lớn nhất khi có i chai nước
- Bài toán cơ sở: f[0] = 0, f[1] = a[1]
- Đáp án bài toán: f[n]
- Công thức quy hoạch động: 
  . Nếu không chọn a[i]: f[i] = f[i - 1]
  . Nếu không chọn a[i - 1]: f[i] = f[i - 2] + a[i];
  . Nếu không chọn a[i - 2]: f[i] = f[i - 3] + a[i] + a[i - 1];

-----------------------------------------------------------------------------------------------------------------------------------------


							BUỔI 3


Little Shop of Flowers: https://dmoj.ca/problem/ioi99p1

Có n cây hoa, có V cái chậu, nếu ta cắm hoa thứ i vào chậu j, ta sẽ có độ thẩm mỹ là c[i][j], ta sẽ cắm hoa vào chậu theo số thứ tự chậu
tăng dần. Nếu cây hoa i đã cắm vào j thì cây hoa i + 1 phải cắm vào j' (j' > j)

Ta muốn cắm toàn bộ N cây sao cho tổng độ thẩm mỹ lớn nhất có thể !!!!!!


3 5
7 23 -5 -24 16
5 21 -4 10 23
-21 5 -4 -20 20


===> 53
     2 4 5 

f[1][1] = max(f[0][0] + c[1][1], f[1][0]) = max(7, -inf) = 7				// j < i
f[1][2] = max(f[0][1] + c[1][2], f[1][1]) = max(23, 7) = 23
f[1][3] = max(f[0][2] + c[1][3], f[1][2]) = max(-5, 23) = 23
f[1][4] = max(f[0][3] + c[1][4], f[1][3]) = max(-24, 23) = 23
f[1][5] = max(f[0][4] + c[1][5], f[1][4]) = max(16, 23) = 23

f[2][1] = max(f[1][0] + c[2][1], f[2][0]) = max(-inf, -inf) = -inf   			// j < i
f[2][2] = max(f[1][1] + c[2][2], f[2][1]) = max(28, -inf) = 28	   // nếu j - 1 < i --> f[i][j] luôn luôn = f[i - 1][j - 1] + c[i][j]	
f[2][3] = max(f[1][2] + c[2][3], f[2][2]) = max(19, 28) = 28
f[2][4] = max(f[1][3] + c[2][4], f[2][3]) = max(33, 28) = 33
f[2][5] = max(f[1][4] + c[2][5], f[2][4]) = max(46, 33) = 46

f[3][1] = max(f[2][0] + c[3][1], f[3][0]) = max(-inf, -inf) = -inf			// j < i
f[3][2] = max(f[2][1] + c[3][2], f[3][1]) = max(-inf, -inf) = -inf			// j < i
f[3][3] = max(f[2][2] + c[3][3], f[3][2]) = max(24, -inf) = 24     // nếu j - 1 < i --> f[i][j] luôn luôn = f[i - 1][j - 1] + c[i][j]
f[3][4] = max(f[2][3] + c[3][4], f[3][3]) = max(8, 24) = 24
f[3][5] = max(f[2][4] + c[3][5], f[3][4]) = max(53, 24) = 53

truy vết: 

i = 3, j = 5

f[3][5] == f[2][4] + c[3][5] 
  ans[3] = 5;
  i = 2 
  j = 4

f[2][4] == f[1][3] + c[2][4]
  ans[2] = 4;
  i = 1
  j = 3

f[1][3] != f[0][2] + c[1][3]
  j = 2

f[1][2] == f[0][1] + c[1][2]
  ans[1] == 2;
  i = 0
  j = 1


Nhận xét: Khi bông hoa thứ i cắm trên bình j thì hoa i + 1 phải cắm trên bình j' (j' > j)

Nếu hoa 1 cắm trên bình 3, hoa 2 cắm trên bình 1 =========> rất khó để quy hoạch động

=======> sử dụng quy hoạch động: 

- Gọi f[i][j] là tổng độ đẹp lớn nhất khi có i hoa và j bình
- Bài toán cơ sở: f[0][0] = 0, f[0][j] = 0, f[i][j] còn lại  = -inf
- Đáp án bài toán: f[n][v]
- Công thức quy hoạch động: 
    ta cần tính f[i][j] = ?
      . Nếu cắm hoa i vào bình j: f[i][j] = f[i - 1][j - 1] + c[i][j]
      . Nếu ta không cắm hoa i vào bình j: f[i][j] = f[i][j - 1]

=====> f[i][j] = max(f[i - 1][j - 1] + c[i][j], f[i][j - 1])
  

Truy vết: 

i = N, j = V
while (i > 0):
   nếu f[i][j] == f[i - 1][j - 1] + c[i][j] (bông hoa thứ i có cắm trên chậu j)
      ans[i] = j
      i--
      j--
   else: 
       j--;
Xuất các ans[i]


	Lời giải: 

#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
const int inf = -1000000000;
int flowers, v;
int vases[105][105];
int f[105][105];
int main () { 
	cin >> flowers >> v;
	for (int i = 1; i <= flowers; i++) {
		for (int j = 1; j <= v; j++) {
			cin >> vases[i][j];
		}
	}
	for (int i = 1; i <= flowers; i++) {
		for (int j = 1; j <= v; j++) {
			f[i][j] = inf;
		}
	}
	for (int j = 1; j <= v; j++) {
		f[0][j] = 0;
	}
	f[0][0] = 0;
	for (int i = 1; i <= flowers; i++) {
		for (int j = i; j <= v; j++) {				// như ví dụ giải tay ở trên ta thấy nếu j < i thì f[i][j] = -inf
			f[i][j] = f[i - 1][j - 1] + vases[i][j];
			if (j - 1 >= i) {				
				f[i][j] = max(f[i][j], f[i][j - 1]);
			}
		}
	}
	int i = flowers;
	int j = v;
	int ans[105];
	int count = 0;
	while (i > 0) {
		if (f[i][j] == f[i - 1][j - 1] + vases[i][j]) {
			ans[i] = j;
			count++;
			i--;
			j--;
		} else {
			j--;
		}		 
	}
	cout << f[flowers][v] << endl;
	for (int i = 1; i <= count; i++) {
		cout << ans[i] << ' ';   
	}
	return 0;
}

	  
					------------------------------------------------------

Trộn xâu: https://oj.vnoi.info/problem/stmerge

Cho 2 chuỗi X và Y, chuỗi X gồm N ký tự X1 X2...XN, chuỗi Y gồm M ký tự Y1 Y2 Y3.. YM

Ta trộn 2 chuỗi X và Y này với nhau sao thành chuỗi T có N + M ký tự sao cho chúng vẫn bảo toàn thứ tự xuất hiện trong 2 chuỗi X và Y

Chi phí để trộn X và Y thành T được tính như sau:

Xét 2 ký tự T[i] và T[i + 1], nếu 2 ký tự cùng thuộc X hoặc Y thì chi phí = 0, nếu 2 ký tự thuộc X[i] và Y[j] thì chi phí + cost[i][j]

Hỏi chi phí nhỏ nhất là bao nhiêu ??????

X = X1 X2

Y = Y1 Y2 Y3

3 5 2 
10 1 9

T = X1 X2 Y1 Y2 Y3 : 10             // 2 ký tự thuộc X2 Y1 thì + cost[2][1] = 10 

T = Y1 Y2 Y3 X1 X2 :  2             // 2 ký tự thuộc Y3 X1 thì + cost[1][3] = 2

T = X1 Y1 Y2 X2 Y3 : 13

		Nháp/*

Ví dụ: 
1
2 3
3 2 30
15 5 4
f[i][j] = 

f[0][0] = 0
f[1][1] = cost[1][1] = 3					
f[1][2] = 2
f[1][3] = 3
f[2][1] = 3
f[2][2] = 2
f[2][3] = 6

X1 Y1 Y2, Y1 X1 Y2, Y1 Y2 X1
[1][1]      [1][1] + [1][2]    [1][2]

-->X trước, Y sau : f[1][2] = f[1][1] = 3
   Y trước, X sau : f[1][2] = cost[1][2] = 2
   X Y xen kẽ     : f[1][2] = f[1][1] + cost[1][2] = 5
X1 Y1 Y2 Y3, Y1 X1 Y2 Y3, Y1 Y2 X1 Y3, Y1 Y2 Y3 X1
3              3 + 2          2 + 30                 30     
[1][1]       [1][1] + [1][2]    [1][2] + [1][3]    [1][3]

--> X trước, Y sau: f[1][3] = f[1][2] =  3
    Y trước, X sau: f[1][3] = 30
    X Y xen kẽ    : f[1][3] = min(5, 32) = 5

f[2][1] 

X1 X2 Y1, X1 Y1 X2, Y1 X1 X2
 15           5               3
[2][1]     [1][1] + [1][2]   [1][1]
---> X trước, Y sau: f[2][1] = 15 
     Y trước, X sau: f[2][1] = 3
     X Y xen kẽ    : f[2][1] = 5
f[2][2] 

X1 X2 Y1 Y2, X1 Y1 X2 Y2, Y1 X1 X2 Y2, Y1 X1 Y2 X2, Y1 Y2 X1 X2
                   23                       8                   10                             2
[2][1]        [1][1] + [2][1] + [2][2]   [1][1] + [2][2]    [1][1] + [1][2] + [2][2]        [1][2]


--->                 f[2][2] = f[2][1] =  15
      Y trước, X sau:f[2][2] = f[1][2] = 2
                     f[2][2] = min(23, 8, 10) = 8

X1 X2 Y1 Y2 Y3, Y1 Y2 Y3 X1 X2, X1 Y1 X2 Y2 Y3, Y1 X1 X2 Y2 Y3, Y1 X1 Y2 X2 Y3, Y1 Y2 X1 X2 Y3, Y1 Y2 X1 Y3 X2, Y1 Y2 Y3 X1 X2
15                30               23                            8                    14
[2][1]          [1][3]        [1][1] + [2][1] + [2][2]       [1][1] + [2][2]       [1][1] + [1][2] + [2][2] + [2][3]
     6                          10                     30
[1][2] + [2][3]          [1][2] + [1][3] + [2][3]    [1][3] 

f[2][3] = f[2][2] = 15
f[2][3] = 30
f[2][3] = min(23, 8, 14, 6, 10) = 6
- Gọi f[i][j] là tổng chi phí nhỏ nhất để trộn i ký tự đầu tiên của chuỗi X và j ký tự đầu tiên của chuỗi Y
- Bài toán cơ sở: f[0][0] = 0, f[i][0] = 0, f[0][j] = 0,    //f[1][1] = cost[1][1], f[i][j] = inf
- Đáp án bài toán: f[m][n]
- Công thức quy hoạch động: 
  .Tình huống 1: 
     Nếu X[i] đứng cuối:
     ..................X[i - 1] X[i] 
     ..................Y[j] X[i]
   --> f[i][j] = min(f[i - 1][j], f[i - 1][j] + cost[i][j])

*/


- Gọi f[i][j][state] là tổng chi phí nhỏ nhất khi trộn i ký tự đầu tiên của X, j ký tự đầu tiên của Y và trạng thái state
  .state = 0: Ta BUỘC ký tự X[i] phải đứng cuối chuỗi trộn
  .state = 1: Ta BUỘC ký tự Y[j] phải đứng cuối chuỗi trộn

- Bài toán cơ sở: f[i][0][0] = 0,  f[i][0][1] = inf, f[0][j][0] = inf, f[0][j][1] = 0
- Đáp án bài toán: for state: 0 -> 1 tìm min(f[m][n][state])
- Công thức quy hoạch động: 
  + ................X[i] : f[i][j][0] = f[i - 1][j][0]
  + ..............Y[j]X[i]:f[i][j][0] = f[i - 1][j][1] + cost[i][j]
----> f[i][j][0] = min(f[i - 1][j][0], f[i - 1][j][1] + cost[i][j])

  + ................Y[j]:  f[i][j][1] = f[i][j - 1][1]
  + ............X[i]Y[j]:  f[i][j][1] = f[i][j - 1][0] + cost[i][j]
----> f[i][j][1] = min(f[i][j - 1][1], f[i][j - 1][0] + cost[i][j])


	Giải tay: 

Input: 2 3
       3 2 30
       15 5 4
Output: 6

f[i][0][0] = 0, f[i][0][1] = inf, f[0][j][0] = inf, f[0][j][1] = 0

f[1][1][0] = min(f[0][1][0], f[0][1][1] + cost[1][1]) = 3
f[1][1][1] = min(f[1][0][1], f[1][0][0] + cost[1][1]) = inf

f[1][2][0] = min(f[0][2][0], f[0][2][1] + cost[1][2]) = 2
f[1][2][1] = min(f[1][1][1], f[1][1][0] + cost[1][2]) = 5

f[1][3][0] = min(f[0][3][0], f[0][3][1] + cost[1][3]) = 30
f[1][3][1] = min(f[1][2][1], f[1][2][0] + cost[1][3]) = 5

f[2][1][0] = min(f[1][1][0], f[1][1][1] + cost[2][1]) = 3
f[2][1][1] = min(f[2][0][1], f[2][0][0] + cost[2][1]) = 15

f[2][2][0] = min(f[1][2][0], f[1][2][1] + cost[2][2]) = 2
f[2][2][1] = min(f[2][1][1], f[2][1][0] + cost[2][2]) = 8

f[2][3][0] = min(f[1][3][0], f[1][3][1] + cost[2][3]) = 9
f[2][3][1] = min(f[2][2][1], f[2][2][0] + cost[2][3]) = 6

Xuất 6

	Lời giải: 

#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
const int inf = 10000000;
int Q;
int m, n;
int cost[1005][1005];
int f[1005][1005][2];
int main () { 
	cin >> Q;
	while (Q--) {
		cin >> m >> n;
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= n; j++) {
				cin >> cost[i][j];
			}
		}
		for (int i = 1; i <= m; i++) {
			f[i][0][0] = 0;
			f[i][0][1] = inf;
		}
		for (int j = 1; j <= n; j++) {
			f[0][j][0] = inf;
			f[0][j][1] = 0;
		}
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= n; j++) {
				f[i][j][0] = min(f[i - 1][j][0], f[i - 1][j][1] + cost[i][j]);
				f[i][j][1] = min(f[i][j - 1][1], f[i][j - 1][0] + cost[i][j]);
			}
		}
		int ans = inf;
		for (int state = 0; state <= 1; state++) {
			ans = min(ans, f[m][n][state]);
		}
		cout << ans << endl;
	}
	return 0;
}



-----------------------------------------------------------------------------------------------------------------------------------------

					BUỔI 4

Best Time to Buy and Sell Stock IV: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/

Cổ phiếu có giá thay đổi trên N ngày, ngày thứ i có giá là prices[i]

Ta có thể thực hiện không quá k giao dịch, mỗi giao dịch ta sẽ mua cổ phiếu tại 1 ngày i, sau đó bán cổ phiếu vào ngày j (j > i)

Nếu ta mua cổ phiếu ở ngày i, ta sẽ mất số tiền là prices[i], nếu bán thì ta sẽ có thêm số tiền là prices[i]

k giao dịch này phải hoàn toàn rời rạc 

Hỏi lợi nhuận cao nhất là bao nhiêu ??????

k = 2, prices = [0,3,2,6,5,0,3]      // thêm số 0 

====> 7 			// mua ở ngày số 2 với số tiền 2 đồng, bán ở ngày số 3 với số tiền 6 đồng --> lời: 6 - 2 = 4 đồng
                                // mua ở ngày số 5 với giá 0 đồng, bán ở ngay số 6 với giá 3 đồng --> lời: 3 - 0 = 3 đồng
/* NHÁP

f[0][0][0] = 0
f[i][0][state] = -inf
f[0][j][state] = 

f[2][1][1] = 


- Gọi f[i][j][state] là lợi nhuận cao nhất khi có i ngày, j giao dịch và trạng thái state
  .state = 0: ta BẮT BUỘC phải BÁN cổ phiếu
  .state = 1: ta BẮT BUỘC phải MUA cổ phiếu
- Bài toán cơ sở: f[i][0][state] = -inf, f[0][j][state] = -inf, f[0][0][0] = 0
- Đáp án bài toán: f[N][k][1]

*/


[p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10]

Giả sử ta thực hiện 3 giao dịch: 

<p1, p4>, <p5, p7>, <p8, p9>

- Gọi f[i][j][state] là tổng lợi nhuận lớn nhất khi có i ngày, hiện tại ta đang trong giao dịch thứ j và trạng thái state
  . state = 0: ta đang MUA cổ phiếu ở ngày i
  . state = 1: ta đang BÁN cổ phiếu ở ngày i
- Bài toán cơ sở: f[0][0][1] = 0, khởi tạo các f[i][j][state] = -inf	
- Đáp án bài toán: Max(f[i][j][1]) với j: 0 -> k, i: 0 -> n
- Công thức quy hoạch động: 

  f[i][j][0] = 
 
 - Nếu ta bán cổ phiếu ở ngày x (x < i): f[i][j][0] = max(f[i][j][0], f[x][j - 1][1] - prices[i])
  
  f[i][j][1] =
 
 - Nếu ta mua cổ phiếu ở ngày x (x < i): f[i][j][1] = max(f[i][j][1],f[x][j][0] + prices[i])

Độ phức tạp: O(k*N^2)	
				
	Lời giải: 
int f[1005][105][2];
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        const int inf = -200005;
        int n = (int)prices.size();
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= k; j++) {    
                f[i][j][0] = inf;
                f[i][j][1] = inf;
            }
        }
        f[0][0][1] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                for (int x = 0; x < i; x++) {
                    f[i][j][0] = max(f[i][j][0], f[x][j - 1][1] - prices[i - 1]);
                    f[i][j][1] = max(f[i][j][1], f[x][j][0] + prices[i - 1]);
                }
            }
        }
        int ans = inf;
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                ans = max(ans, f[i][j][1]);
            }
        }
        return ans;
    }
}; 

   
					------------------------------------------------------

Ioi07 Miners: https://oj.vnoi.info/problem/nkminers

Có 2 mỏ than, có N đợt vận chuyển đồ ăn. Đợt thứ i sẽ có món ăn a[i]. a[i] chỉ gồm 1 trong 3 loại thịt ('M'), cá('F'), bánh mì('B').
Ta sẽ phân phối N món ăn này vào các mỏ và lượng than mà công nhân làm được sẽ tính như sau: 

 Cứ với 1 món ăn đi vào mỏ, xét 3 món ăn cuối cùng, nếu chúng giống nhau thì lượng than sinh ra là 1, nếu có 2 món khác nhau, lượng than
sinh ra là 2, nếu cả 3 món đều khác nhau thì lượng than sinh ra là 3

Hỏi: Tổng lượng than mà 2 mỏ có thể sản xuất lớn nhất là bao nhiêu ?????

n = 6

MBMFFB
112212			// cách chọn


mỏ 1 = [M, B, F] = 1 + 2 + 3 = 6

mỏ 2 = [M, F, B] = 1 + 2 + 3 = 6



Ta chuyển đổi nếu là 'M' -> 1, 'F' -> 2, 'B' -> 3

Thiết kế 1 hàm calc(a, b, c) là hàm trả ra lượng than khi có 3 món a, b, c

đặt ret = 0

nếu a == 1 || b == 1 || c == 1: ret++
nếu a == 2 || b == 2 || c == 2: ret++
nếu a == 3 || b == 3 || c == 3: ret++



					------------------------------------------------------
Kinh nghiệm: https://lqdoj.edu.vn/problem/twopaths

(x, y) -> (x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)		// không dùng quy hoạch động được


for x: 1 -> n
  for y: 1 -> m
    nếu bài toán (x, y) đã có lời giải
      ta tính cho bài toán (x + 1, y) và (x, y + 1)
-----> dùng quy hoạch động được vì (x, y) luôn xuất hiện trước (x + 1, y) và (x, y + 1)


- Gọi f[xA][yA][xB][yB] là tổng điểm lớn nhất có thể khi vị trí hiện tại của An là (xA, yA), của Bình là (xB, yB)
  (xA < xB, xA == xB nếu cùng đứng đầu hoặc cùng đứng cuối)
- Bài toán cơ sở: f[1][1][1][1] = 0, khởi tạo các f[xA][yA][xB][yB] = -inf
- Đáp án bài toán: f[N][M][N][M]
- Công thức quy hoạch động: 
 
  Khi ta đang đứng tại f[xA][yA][xB][yB] != -inf
 
  . An sang phải, Bình cũng sang phải (yA < M và yB < M)
    f[xA][yA + 1][xB][yB + 1] = max(f[xA][yA + 1][xB][yB + 1], f[xA][yA][xB][yB] + cost[xA][yA + 1] + cost[xB][yB + 1]) 

  . An sang phải, Bình xuống dưới (yA < M và xB < N)
    f[xA][yA + 1][xB + 1][yB] = max(f[xA][yA + 1][xB + 1][yB], f[xA][yA][xB][yB] + cost[xA][yA + 1] + cost[xB + 1][yB])

  . An xuống dưới, Bình xuống dưới (xA < N và xB < N)
    f[xA + 1][yA][xB + 1][yB] = max(f[xA + 1][yA][xB + 1][yB], f[xA][yA][xB][yB] + cost[xA + 1][yA] + cost[xB + 1][yB])

  . An xuống dưới, Bình sang phải
    điều kiện: 
      xA < N và yB < M và (xB - xA >= 2 || (xB == N && yA == M && xB - xA == 1))
    f[xA + 1][yA][xB][yB + 1] = max(f[xA + 1][yA][xB][yB + 1], f[xA][yA][xB][yB] + cost[xA + 1][yA] + cost[xB][yB + 1])

1 <= N, M <= 200

f[xA][yA][xB][yB] -----> mảng này sẽ là 200^4 ===> tràn bộ nhớ

-----> cần tối ưu độ phức tạp

quãng đường đi của An và Bình LUÔN LUÔN bằng nhau

số lượng bước của cả An và Bình = (N + M) - 2

*********Tối ưu: 

Nhận xét: Tổng số ô của cả An và Bình đều bằng nhau và bằng N + M - 2

Công thức để suy luận ra được yA, yB

xA - 1 + yA - 1 = steps <=> yA = steps + 2 - xA
xB - 1 + yB - 1 = steps <=> yB = steps + 2 - xB

- Gọi f[steps][xA][xB] là tổng giá trị lớn nhất khi An và Bình sau steps bước thì An đang đứng tại xA, Bình đứng tại xB (xA < xB)
- Bài toán cơ sở: f[0][1][1] = 0, f[steps][xA][xB] = -inf
- Đáp án bài toán: f[(N + M) - 2][N][N] 
- Công thức quy hoạch động: 
  Khi ta có f[steps][xA][xB] != -inf
  . An sang phải, Bình cũng sang phải (steps + 2 - xA < M và steps + 2 - xB < M)
    f[steps + 1][xA][xB] = max(f[steps + 1][xA][xB], f[steps][xA][xB] + cost[xA][(steps + 2 - xA) + 1] + cost[xB][(steps + 2 - xB) + 1])

  . An xuống dưới, Bình cũng xuống dưới (xA < N và xB < N)
    f[steps + 1][xA + 1][xB + 1] = max(f[steps + 1][xA + 1][xB + 1], f[steps][xA][xB] + cost[xA + 1][yA] + cost[xB + 1][yB])

  . An sang phải, Bình xuống dưới (yA < M và xB < N)
    f[steps + 1][xA][xB + 1] = max(f[steps + 1][xA][xB + 1], f[steps][xA][xB] + cost[xA][yA + 1] + cost[xB + 1][yB])

  . An xuống dưới, Bình sang phải
    điều kiện: 
     xA < N và yB < M  (xB - xA >= 2 || (xB == N && yA == M && xB - xA == 1))
    f[steps + 1][xA + 1][xB] = max(f[steps + 1][xA + 1][xB], f[steps][xA][xB] + cost[xA + 1][yA] + cost[xB][yB + 1])

	
	Lời giải: 

#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
const int inf = -10000000;
int f[400][205][205];
int cost[205][205];
int n, m;


bool check (int xA, int yA, int xB, int yB) {
	if (xA != xB || yA != yB) {
		return true;
	}
	if (xA == xB && xA == n && yA == yB && yB == m) {
		return true;
	}
	return false;
}
int main () { 
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> cost[i][j];
		}
	}
	int steps = n + m - 2;
	
	for (int i = 0; i <= steps; i++) {
		for (int xA = 1; xA <= n; xA++) {
			for (int xB = 1; xB <= n; xB++) {
				f[i][xA][xB] = inf;
			}
		}
	}
	f[0][1][1] = 0;
	for (int i = 0; i < steps; i++) {
		for (int xA = 1; xA <= n; xA++) {
			for (int xB = xA; xB <= n; xB++) {
				int yA = i + 2 - xA;
				int yB = i + 2 - xB;
				if (check(xA, yA + 1, xB, yB + 1) == true) {
					f[i + 1][xA][xB] = max(f[i + 1][xA][xB], f[i][xA][xB] + cost[xA][yA + 1] + cost[xB][yB + 1]);
				}
				if (xB + 1 <= n) {
					if (check(xA + 1, yA, xB + 1, yB) == true) {
						f[i + 1][xA + 1][xB + 1] = max(f[i + 1][xA + 1][xB + 1], f[i][xA][xB] + cost[xA + 1][yA] + cost[xB + 1][yB]);
					}
					if (check(xA, yA + 1, xB + 1, yB) == true) {
						f[i + 1][xA][xB + 1] = max(f[i + 1][xA][xB + 1], f[i][xA][xB] + cost[xA][yA + 1] + cost[xB + 1][yB]);
					}
				}
				if (xA + 1 <= xB) {
					if (check(xA + 1, yA, xB, yB + 1) == true) {
						f[i + 1][xA + 1][xB] = max(f[i + 1][xA + 1][xB], f[i][xA][xB] + cost[xA + 1][yA] + cost[xB][yB + 1]);
					}
				}
			}
		}
	}
	cout << f[steps][n][n] << endl;
	return 0;
}


					------------------------------------------------------
Lazy cow: https://oj.vnoi.info/problem/lazycows

ví dụ: 
n = 6, k = 2, b = 12

		|     |     | cow | cow |     |     | cow |     |     |     |     |     |	
1 3             -------------------------------------------------------------------------
1 4		|     |     |     |     |     | cow |     | cow |     | cow |     |     |
1 7             -------------------------------------------------------------------------
2 6
2 8
2 10

f[3][2][0] = 3		
f[3][2][1] = 4
f[3][1][0] = inf
f[3][1][1] = 8

- Gọi f[i][j][state] là tổng diện tích nhỏ nhất khi có i bò, ta đã sử dụng j chuồng và chuồng phủ lên con bò thứ i là state
  + state = 0: con bò thứ i được phủ bằng chuồng có độ rộng là 1
  + state = 1: con bò thứ i được phủ bằng chuồng có độ rộng là 2
  + state = 2: con bò thứ i được phủ bằng chuồng có độ rộng là 1, hàng còn lại cũng có 1 chuồng có độ rộng là 1 và được kéo dài đến cùng
cột của con bò thứ i 

- Bài toán cơ sở: f[1][1][0] = 1, f[1][1][1] = 2, f[1][2][2] = 2, f[i][j][state] = inf
- Đáp án bài toán: min(f[n][k][0], f[n][k][1], f[n][k][2])
- Công thức quy hoạch động: 

  khi ta có f[i][j][state] != inf
 
  Xét bò thứ i + 1
  Ta cho bò i + 1 trong 1 chuồng mới có độ rộng là 1: 
  f[i + 1][j + 1][0] = min(f[i + 1][j + 1][0], f[i][j][state] + 1)

  Ta cho bò i + 1 trong 1 chuồng mới có độ rộng là 2:

  f[i + 1][j + 1][1] = min(f[i + 1][j + 1][1], f[i][j][state] + 2)

  Ta cho bò i + 1 trong trạng thái state = 2 và sử dụng 2 chuồng mới: 

  f[i + 1][j + 2][2] = min(f[i + 1][j + 2][2], f[i][j][state] + 2)  

  Với state = 0: 
  Nếu con i + 1 cùng hàng với con i: 
  f[i + 1][j][0] = min(f[i + 1][j][0], f[i][j][state] + a[i + 1].y - a[i].y)		// neeus a[i + 1].x == a[i].x
  f[i + 1][j + 1][2] = min(f[i + 1][j + 1][2], f[i][j][state] + a[i + 1].y - a[i].y + 1)

  Nếu con i + 1 khác hàng với con i:
  f[i + 1][j + 1][2] = min(f[i + 1][j + 1][2], f[i][j][state] + a[i + 1].y - a[i].y + 1)
	
  Với state = 1: 
  f[i + 1][j][1] = min(f[i + 1][j][1], f[i][j][state] + 2*(a[i + 1].y - a[i].y)

  Với state = 2: 
  f[i + 1][j][0] = min(f[i + 1][j][0], f[i][j][state] + a[i + 1].y - a[i].y)
  f[i + 1][j][2] = min(f[i + 1][j][2], f[i][j][state] + 2*(a[i + 1].y - a[i].y))


	Lời giải:
#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
const int inf = 1000000000;
int n, k, b;
pair <int, int> cow[1005];
int f[1005][1005][3];


int main () { 
	int t;
	cin >> t;
	while (t--) {
		cin >> n >> k >> b;
		for (int i = 1; i <= n; i++) {
			cin >> cow[i].second >> cow[i].first;	// để cột là second, hàng là first cho dễ sắp xếp
		}
		for (int i = 0; i <= n; i++) {
			for (int j = 0; j <= k; j++) {
				for (int state = 0; state <= 2; state++) {
					f[i][j][state] = inf;
				}
			}
		}
		sort(cow + 1, cow + 1 + n);		// sắp xếp theo thứ tự tăng dần của cột
		f[1][1][0] = 1;
		f[1][1][1] = 2;
		if (k >= 2) {
			f[1][2][2] = 2;
		}
		for (int i = 1; i < n; i++) {
			for (int j = 1; j <= k; j++) {
				for(int state = 0; state <= 2; state ++) {
					if (f[i][j][state] == inf) {
						continue;
					}
					int val = f[i][j][state];
					if (j + 1 <= k) {
						f[i + 1][j + 1][0] = min(f[i + 1][j + 1][0], val + 1);
						f[i + 1][j + 1][1] = min(f[i + 1][j + 1][1], val + 2);
						if (j + 2 <= k) {
							f[i + 1][j + 2][2] = min(f[i + 1][j + 2][2], val + 2);
						}
					}
					if (state == 0) {
						if (j + 1 <= k) {
							f[i + 1][j + 1][2] = min(f[i + 1][j + 1][2], val + cow[i + 1].first - cow[i].first + 1);
						}
						if (cow[i + 1].second == cow[i].second) {
							f[i + 1][j][0] = min(f[i + 1][j][0], val + cow[i + 1].first - cow[i].first);
						}
					} else if (state == 1) {
						f[i + 1][j][1] = min(f[i + 1][j][1], val + 2*(cow[i + 1].first - cow[i].first));
					} else {
						if (j + 1 <= k) {
							f[i + 1][j + 1][2] = min(f[i + 1][j + 1][2], val + cow[i + 1].first - cow[i].first + 1);
						}
						if (cow[i + 1].second != cow[i].second) {
							f[i + 1][j][0] = min(f[i + 1][j][0], val + cow[i + 1].first - cow[i].first);
						}
						f[i + 1][j][2] = min(f[i + 1][j][2], val + 2*(cow[i + 1].first - cow[i].first));
					}	
				}
			}
		}
		int ans = inf;
		for (int state = 0; state <= 2; state++) {
			ans = min(ans, f[n][k][state]);
		}
		cout << ans << endl;
	}	
	return 0;
}


	Lời giải:
#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
const int inf = 1000000000;
int n, k, b;
pair <int, int> cow[1005];
int f[1005][1005][3];

bool cmp (pair <int, int> a, pair <int, int> b) {		// viết hàm để tí sắp xếp theo thứ tự tăng dần theo second
	if (a.second < b.second) {
		return true;
	}
	return false;
}
int main () { 
	int t;
	cin >> t;
	while (t--) {
		cin >> n >> k >> b;
		for (int i = 1; i <= n; i++) {
			cin >> cow[i].first >> cow[i].second;	// để hàng là first, cột là second
		}
		for (int i = 0; i <= n; i++) {
			for (int j = 0; j <= k; j++) {
				for (int state = 0; state <= 2; state++) {
					f[i][j][state] = inf;
				}
			}
		}
		sort(cow + 1, cow + 1 + n, cmp);	// sắp xếp theo thứ tự tăng dần của cột
		f[1][1][0] = 1;
		f[1][1][1] = 2;
		if (k >= 2) {
			f[1][2][2] = 2;
		}
		for (int i = 1; i < n; i++) {
			for (int j = 1; j <= k; j++) {
				for(int state = 0; state <= 2; state ++) {
					if (f[i][j][state] == inf) {
						continue;
					}
					int val = f[i][j][state];
					if (j + 1 <= k) {
						f[i + 1][j + 1][0] = min(f[i + 1][j + 1][0], val + 1);
						f[i + 1][j + 1][1] = min(f[i + 1][j + 1][1], val + 2);
						if (j + 2 <= k) {
							f[i + 1][j + 2][2] = min(f[i + 1][j + 2][2], val + 2);
						}
					}
					if (state == 0) {
						if (j + 1 <= k) {
							f[i + 1][j + 1][2] = min(f[i + 1][j + 1][2], val + cow[i + 1].second - cow[i].second + 1);
						}
						if (cow[i + 1].first == cow[i].first) {
							f[i + 1][j][0] = min(f[i + 1][j][0], val + cow[i + 1].second - cow[i].second);
						}
					} else if (state == 1) {
						f[i + 1][j][1] = min(f[i + 1][j][1], val + 2*(cow[i + 1].second - cow[i].second));
					} else {
						if (j + 1 <= k) {
							f[i + 1][j + 1][2] = min(f[i + 1][j + 1][2], val + cow[i + 1].second - cow[i].second + 1);
						}
						if (cow[i + 1].first != cow[i].first) {
							f[i + 1][j][0] = min(f[i + 1][j][0], val + cow[i + 1].second - cow[i].second);
						}
						f[i + 1][j][2] = min(f[i + 1][j][2], val + 2*(cow[i + 1].second - cow[i].second));
					}	
				}
			}
		}
		int ans = inf;
		for (int state = 0; state <= 2; state++) {
			ans = min(ans, f[n][k][state]);
		}
		cout << ans << endl;
	}	
	return 0;
}


-----------------------------------------------------------------------------------------------------------------------------------------


							BUỔI 5



Alyona and Strings: https://codeforces.com/problemset/problem/682/D


Cho 2 chuỗi s1(gồm N ký tự) và s2(gồm M ký tự).

Ta tiến hành chọn một vài cụm các ký tự liên tục trong chuỗi s1 và s2 sao cho: 

Số lượng cụm của mỗi chuỗi = k
Các cụm tương ứng phải giống nhau

Số lượng ký tự được chọn trong các cụm lớn nhất có thể 

Hỏi số lượng ký tự là bao nhiêu ??????

k = 3
s1 = [aab]bc[deab]bc[d]aad

s2 = cac[aab][deab]ccccb[d]ef

=====> 8


ví dụ:

9 12 4
[bba][aaba]bb
ab[bba]bba[aaba]

===> 7
f[3][5][1][2] = 3


Nháp  /*
- Gọi f[i][j][z][state] là số lượng số ký tự lớn nhất khi chuỗi s có i ký tự, chuỗi t có j ký tự, và đang có z chuỗi được chọn
  + state = 0: nếu cả 2 ký tự của cả 2 chuỗi không được bao gồm trong chuỗi con tối đa
  + state = 1: nếu cả 2 ký tự của cả 2 chuỗi được bao gồm trong chuỗi con tối đa

- Bài toán cơ sở: f[0][0][z][state] = 0, f[i][j][z][state] = -inf
- Đáp án bài toán: max(f[n][m][k][0], f[n][m][k][1])
- Công thức quy hoạch động: 

  Giả sử f[i][j][z][state] != -inf;
  .Ta không chọn 1 ký tự ở s và giữ nguyên ký tự ở t: 
   f[i + 1][j][z][0] = max(f[i + 1][j][z][0], f[i][j][z][state])
   
  .Ta không chọn 1 ký tự ở t và giữ nguyên ký tự ở s: 
   f[i][j + 1][z][0] = max(f[i][j + 1][z][0], f[i][j][z][state])

  Nếu s[i] == t[j]
    nếu end = 1: 
      f[i + 1][j + 1][k][1] = max(f[i + 1][j + 1][k][1], f[i][j][z][state] + 1)
    nếu end = 0: 
      f[i + 1][j + 1][k + 1][1] = max(f[i + 1][j + 1][k + 1][1], f[i][j][z][state] + 1)

*/



- Gọi f[i][j][groups] là số lượng ký tự lớn nhất khi có i ký tự đầu tiên của chuỗi s1, j ký tự đầu tiên của chuỗi s2 và ta đã chia được
thành groups nhóm
- Bài toán cơ sở: f[0][0][0] = 0, f[i][j][groups] = -1
- Đáp án bài toán: f[n][m][k]
- Công thức quy hoạch động: 

  Khi ta có f[i][j][groups] != -1
  
   . Ta không quan tâm đến ký tự s1[i + 1]:
     f[i + 1][j][groups] = max(f[i + 1][j][groups], f[i][j][groups])

   . Ta không quan tâm đến ký tự s2[j + 1]:
     f[i][j + 1][groups] = max(f[i][j + 1][groups], f[i][j][groups])
   
   . Nếu s1[i + 1] == s2[j + 1]: 
       + Nếu ta đưa s1[i + 1] và s2[j + 1] vào 1 nhóm mới: 
         f[i + 1][j + 1][groups + 1] = max(f[i + 1][j + 1][groups + 1], f[i][j][groups] + 1)
       
       + Nếu ta đưa s1[i + 1] và s2[j + 1] vào nhóm cũ (s1[i] == s2[j]): 
         f[i + 1][j + 1][groups] = max(f[i + 1][j + 1][groups], f[i][j][groups] + 1)

				--------------------------------------------------------

- Gọi f[i][j][groups][state] là số lượng ký tự lớn nhất khi có i ký tự đầu tiên của chuỗi s1, j ký tự đầu tiên của chuỗi s2 và ta đã chia
thành groups nhóm 
   
   . state = 0: những tình huống còn lại (không phải như state = 1)
   . state = 1: s1[i] == s2[j] và 2 ký tự này hiện tại đang ở cùng 1 nhóm
   
- Bài toán cơ sở: f[0][0][0][0] = 0, f[i][j][groups][state] = -1
- Đáp án bài toán: max(f[n][m][k][0], f[n][m][k][1])
- Công thức quy hoạch động: 
  
  Khi ta có f[i][j][groups][state] != -1
 	
   . Ta không quan tâm đến ký tự s1[i + 1]:
     f[i + 1][j][groups][0]= max(f[i + 1][j][groups][0], f[i][j][groups][state])

   . Ta không quan tâm đến ký tự s2[j + 1]:
     f[i][j + 1][groups][0] = max(f[i][j + 1][groups][0], f[i][j][groups][state])

   . Nếu s1[i] == s2[j]: 
      + Cho s1[i + 1] và s2[j + 1] cùng 1 nhóm mới: 
        f[i + 1][j + 1][groups + 1][1] = max(f[i + 1][j + 1][groups + 1][1], f[i][j][groups][state] + 1)
      
      + Khi state == 1: f[i + 1][j + 1][groups][1] = max(f[i + 1][j + 1][groups][1], f[i][j][groups][state] + 1)
 
	Lời giải
#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
int n, m, k;
string s, t;
int f[1005][1005][12][2];
int main () { 
	cin >> n >> m >> k;
	cin >> s >> t;
	for (int i = 0; i <= n; i++) {
		for (int j = 0; j <= m; j++) {
			for (int groups = 0; groups <= k; groups++) {
				for (int state = 0; state <= 1; state++) {
					f[i][j][groups][state] = -1;
				}
			}
		}
	}
	f[0][0][0][0] = 0;
	
	for (int i = 0; i <= n; i++) {
		for (int j = 0; j <= m; j++) {
			for (int groups = 0; groups <= k; groups++) {
				for (int state = 0; state <= 1; state++) {
					if (f[i][j][groups][state] == -1) {
						continue;
					}
					if (i < n) {
						f[i + 1][j][groups][0] = max(f[i + 1][j][groups][0], f[i][j][groups][state]);    // khong quan tam den s[i + 1]
					}
					if (j < m) {
						f[i][j + 1][groups][0] = max(f[i][j + 1][groups][0], f[i][j][groups][state]);    // khong quan tam den t[j + 1]
					}
					if (i < n && j < m && s[i] == t[j]) {  // state = 1: s[i] == t[j] va 2 ky tu nay hien tai dang cung 1 nhom
						f[i + 1][j + 1][groups + 1][1] = max(f[i + 1][j + 1][groups + 1][1], f[i][j][groups][state] + 1);  // cho s[i + 1] va t[j + 1] vao 1 nhom moi
						if (state == 1) {
							f[i + 1][j + 1][groups][1] = max(f[i + 1][j + 1][groups][1], f[i][j][groups][state] + 1);   // cho s[i + 1] va t[j + 1] vao nhom cu
						}
					}
				}
			}
		}
	}
	cout << max(f[n][m][k][0], f[n][m][k][1]) << endl;
	return 0;
}

Độ phức tạp: O(n + 1) * (m + 1) * (k + 1) * 2)
	Giải tay: 
3 2 2
abc
ab
--> 2		

// i = 0, j = 0, groups = 0, state = 0
f[1][0][0][0] = 0
f[0][1][0][0] = 0

s[0] == t[0]
f[1][1][1][1] = 1

// i = 0, j = 0, groups = 0, state = 1
continue

// i = 0, j = 0, groups = 1, state = 0
continue

// i = 0, j = 0, groups = 1, state = 1
continue

// i = 0, j = 0, groups = 2, state = 0
continue

// i = 0, j = 0, groups = 2, state = 1
continue

// i = 0, j = 1, groups = 0, state = 0
f[1][1][0][0] = 0
f[0][2][0][0] = 0

// i = 0, j = 1, groups = 0, state = 1
continue

// i = 0, j = 1, groups = 1, state = 0
continue

// i = 0, j = 1, groups = 1, state = 1
continue

// i = 0, j = 1, groups = 2, state = 0
continue

//i = 0, j = 1, groups = 2, state = 1
continue

// i = 0, j = 2, groups = 0, state = 0
f[1][2][0][0] = 0

// i = 0, j = 2, groups = 0, state = 1
continue

// i = 0, j = 2, groups = 1, state = 0
continue

// i = 0, j = 2, groups = 1, state = 1
continue

// i = 0, j = 2, groups = 2, state = 0
continue

// i = 0, j = 2, groups = 2, state = 1
continue

// i = 1, j = 0, groups = 0, state = 0
f[2][0][0][0] = 0
f[1][1][0][0] = 0

// i = 1, j = 0, groups = 0, state = 1
continue

// i = 1, j = 0, groups = 1, state = 0
continue

// i = 1, j = 0, groups = 1, state = 1
continue

// i = 1, j = 0, groups = 2, state = 0
continue

// i = 1, j = 0, groups = 2, state = 1
continue

// i = 1, j = 1, groups = 0, state = 0
f[2][1][0][0] = 0
f[1][2][0][0] = 0

s[1] = t[1]
f[2][2][1][1] = 1

// i = 1, j = 1, groups = 0, state = 1
continue

// i = 1, j = 1, groups = 1, state = 0
continue

// i = 1, j = 1, groups = 1, state = 1
f[2][1][1][0] = 1
f[1][2][1][0] = 1

s[1] == t[1]
f[2][2][2][1] = 2
state == 1
f[2][2][1][1] = 2

// i = 1, j = 1, groups = 2, state = 0
continue

// i = 1, j = 1, groups = 2, state = 1
continue

// i = 1, j = 2, groups = 0, state = 0
f[2][2][0][0] = 0

// i = 1, j = 2, groups = 0, state = 1
continue

// i = 1, j = 2, groups = 1, state = 0
continue

// i = 1, j = 2, groups = 1, state = 1
continue

// i = 1, j = 2, groups = 2, state = 0
continue

// i = 1, j = 2, groups = 2, state = 1
continue

// i = 2, j = 0, groups = 0, state = 0
f[3][0][0][0] = 0
f[2][1][0][0] = 0

// i = 2, j = 0, groups = 0, state = 1
continue

// i = 2, j = 0, groups = 1, state = 0
continue

// i = 2, j = 0, groups = 1, state = 1
continue

// i = 2, j = 0, groups = 2, state = 0
continue

// i = 2, j = 0, groups = 2, state = 1
continue

// i = 2, j = 1, groups = 0, state = 0
f[3][1][0][0] = 0
f[2][2][0][0] = 0

// i = 2, j = 1, groups = 0, state = 1
continue

// i = 2, j = 1, groups = 1, state = 0
f[3][1][1][0] = 1
f[2][2][1][0] = 1

// i = 2, j = 1, groups = 1, state = 1
continue

// i = 2, j = 1, groups = 2, state = 0
continue

// i = 2, j = 1, groups = 2, state = 1
continue

// i = 2, j = 2, groups = 0, state = 0
f[3][2][0][0] = 0

// i = 2, j = 2, groups = 0, state = 1
continue

// i = 2, j = 2, groups = 1, state = 0
f[3][2][1][0] = 1

// i = 2, j = 2, groups = 1, state = 1
f[3][2][1][0] = 2

// i = 2, j = 2, groups = 2, state = 0
continue

// i = 2, j = 2, groups = 2, state = 1
f[3][2][2][0] = 2

// i = 3, j = 0, groups = 0, state = 0
f[3][1][0][0] = 0

// i = 3, j = 0, groups = 0, state = 1
continue

// i = 3, j = 0, groups = 1, state = 0
continue

// i = 3, j = 0, groups = 1, state = 1
continue

// i = 3, j = 0, groups = 2, state = 0
continue

// i = 3, j = 0, groups = 2, state = 1
continue

// i = 3, j = 1, groups = 0, state = 0
f[3][2][0][0] = 0

// i = 3, j = 1, groups = 0, state = 1
continue

// i = 3, j = 1, groups = 1, state = 0
f[3][2][1][0] = 1

// i = 3, j = 1, groups = 1, state = 1
continue

// i = 3, j = 1, groups = 2, state = 0
continue

// i = 3, j = 1, groups = 2, state = 1
continue

// i = 3, j = 2, groups = 0, state = 0

// i = 3, j = 2, groups = 0, state = 1
continue

// i = 3, j = 2, groups = 1, state = 0

// i = 3, j = 2, groups = 1, state = 1
continue

// i = 3, j = 2, groups = 2, state = 0
f[3][2][2][0] = 2			// Xuất 2

// i = 3, j = 2, groups = 2, state = 1
continue
				
				-------------------------------------------------------

Exam Cheating: https://codeforces.com/problemset/problem/796/E

Trong 1 kỳ thi, có N câu trắc nghiệm. Bạn là 1 thí sinh không biết làm câu nào. Nhưng may mắn ta ngồi cạnh bạn An và Bình. Bạn An sẽ

biết mà những câu a1, a2, a3,...., ak. Bạn Bình sẽ biết làm những câu b1, b2,...., bp. Ta ngồi giữa 2 bạn và ta có thể nhìn bài của cả

2 bạn. Với mỗi lần nhìn bài, ta có thể chép bài m câu liên tục và số lần chép bài tối đa là g.

Hỏi tổng điểm lớn nhất ta có thể đạt được là bao nhiêu ??????

m = 3, g = 3

N = 12

An: 1 3 4 7 9 10
Bình: 4 5 10 12

An   : o x o o x x o x o o x x
Bình : x x x o o x x x x o x o

Chép 1 -> 3 của bạn An: 2 điểm
Chép 3 -> 5 của bạn Bình: 2 điểm
Chép 8 -> 10 của bạn An: 2 điểm

===> 6 điểm 

Điều kiện: 1 <= n, p <= 1000, 1 <= k <= 50

-Gọi f[i][j][kA][kB] là tổng điểm lớn nhất khi ta xét i câu trắc nghiệm ban đầu, hiện tại ta có j đợt chép và ta đã chép kA câu liên tục
của bạn An, kB câu liên tục của bạn Bình
- Bài toán cơ sở: f[0][0][0][0] = 0, f[i][j][kA][kB] = -1
- Đáp án bài toán: max(f[n][p][kA][kB]) với mọi kA: 0 -> k, kB: 0 -> k
- Công thức quy hoạch động: 
  
  Ta tạo hàm score(i, checkA, checkB): trả về số điểm ta sẽ nhận được ở câu i cùng 2 trạng thái checkA và checkB

  checkA: ta có chép câu i của An
  checkB: ta có chép câu i của Bình

  Khi ta có f[i][j][kA][kB] != -1

  . Ta mở thêm 2 đợt chép bài mới, 1 cho An, 1 cho Bình: 
  
    f[i + 1][j + 2][1][1] = max(f[i + 1][j + 2][1][1], f[i][j][kA][kB] + score(i + 1, true, true))

  . Ta mở thêm 1 đợt chép bài mới cho An 
    đăt nextkA: số lượng bài liên tục mà An chép (khi ở câu i + 1). nextkA = 1
    đặt nextkB: số lượng bài liên tục mà Bình chép (khi ở câu i + 1). nextkB = (kB == 0 || kB == k ? 0 : kB + 1)
   
    f[i + 1][j + 1][1][nextkB] = max(f[i + 1][j + 1][1][nextkB], f[i][j][kA][kB] + score(i + 1, true, nextB > 0)) 

   . Ta mở thêm 1 đợt chép bài mới cho Bình
     đặt nextkA: số lượng bài liên tục mà An chép (khi ở câu i + 1). nextkA = (kA == 0 || kB == k ? 0 : kA + 1)
     đặt nextkB: số lượng bài liên tục mà Bình chép (khi ở câu i + 1). nextkB = 1
   
     f[i + 1][j + 1][nextkA][1] = max(f[i + 1][j + 1][nextkA][1], f[i][j][kA][kB] + score(i + 1, nextkA > 0, true))
  
   . Ta không mở đợt chép bài nào mới: 
     đặt nextkA: số lượng bài liên tục mà An chép (khi ở câu i + 1). nextkA = (kA == 0 || kB == k ? 0 : kA + 1)
     đặt nextkB: số lượng bài liên tục mà Bình chép (khi ở câu i + 1). nextkB = (kB == 0 || kB == k ? 0 : kB + 1)

     f[i + 1][j][nextkA][nextkB] = max(f[i + 1][j][nextkA][nextkB], f[i][j][kA][kB] + score(i + 1, nextkA > 0, nextkB > 0))

Độ phức tạp: O(N * P * K^2)

Cần bao nhiêu lần chép bài thì sẽ chép được toàn bộ câu trắc nghiệm của An ?????????

N = 1000, K = 50 =====> chỉ cần 20 lần chép bài 

=======> số lần chép câu trắc nghiệm tối đa của 1 bạn: 

Đặt X = N/K, nếu N % K != 0: X++
======> số lần chép trắc nghiệm tối đa của 2 bạn là 2*X

Nếu p >= 2 * X =======> Duyệt toàn bộ các câu trắc nghiệm i, ta cộng ans += score(i, true, true)

else: Quy hoạch động

O(N * P * K^2)

N * P * K^2 < N * 2 * X * K^2 = N * 2 * N/K * K^2 = 2 * N^2 * Kz

Về mặt không gian: f[2][1005][52][52]  	   

-----------------------------------------------------------------------------------------------------------------------------------------


							BUỔI 6




-----------------------------------------------------------------------------------------------------------------------------------------


		
							BUỔI 7

https://vjudge.net/contest/561985

Bài D: 

- Gọi f[i][j] là tổng giá trị khi lấy đươc i món hàng và túi đang có tải trọng là j
- Bài toán cơ sở: f[0][j] = 0, f[i][0] = 0
- Đáp án bài toán: f[n][m]
- Công thức quy hoạch động: 
  . Ta không lấy món đồ thứ i: 
    f[i][j] = f[i - 1][j]
  . Ta lấy món đồ thứ i (j >= w[i]): f[i][j] = max(f[i][j], f[i - 1][j - w[i]] + c[i])


Loi giai: 
#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;

int n, m;
int w[105];
long long v[105];
long long f[105][100005];
int main () { 
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> w[i] >> v[i];
	}
	memset(f, 0, sizeof(f));
	for (int i = 1; i <= n; i++) {
		f[i][0] = 0;
	}
	for (int j = 1; j <= m; j++) {
		f[0][j] = 0;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			f[i][j] = f[i - 1][j];
			if (j >= w[i]) {
				f[i][j] = max(f[i][j], f[i - 1][j - w[i]] + v[i]);
			}
		}
	}
	cout << f[n][m] << endl;
	return 0;
}



Bài B: 


2 7
2 3

---> First

nếu T chọn lấy 2 viên đá, sẽ còn lại 5 viên đá:
 . J sẽ lấy 3 viên đá (còn lại 2 viên đá) và T lấy 2 viên đá---> T thắng
 . J sẽ lấy 2 viên đá (còn lại 3 viên đá) và T lấy 3 viên đá---> T thắng

nếu T chọn lấy 3 viên đá, sẽ còn lại 4 viên đá: 
 . J sẽ lấy 3 viên đá (còn lại 1 viên đá)
 . J sẽ lấy 2 viên đá (còn lại 2 viên đá), T lấy 2 viên đá --> T thắng


- Gọi f[i][


Bài A: 

4
10 20 30 40
==> 190



(10, 20, 30, 40)

(30, 30, 40) --> (60, 40)
(60, 40) --> (100)
---> 100 + 60 + 30 = 190
 f[2][4] = 140 = f[2][3] + 
 f[1][3] = 60 = f[1][2] + a[3]


(10, 20, 30, 40) ---> (10, 20, 70)
(10, 20, 70) --> (30, 70)
(30, 70) --> (100)
-> 100 + 30 + 70 = 200

6
7 6 8 6 1 1

1 1 6 8 --> 2 6 8
2 6 8 -- > 8 8
8 8 --> 16 



for i: n -> 1
  for j: i -> n

f[6][6] = a[6] = 1

f[5][5] = a[5] = 1
f[5][6] = a[5] + a[6] = 2

f[4][4] = a[4] = 6
f[4][5] = a[4] + a[5] = 7
f[4][6] = a[4] + f[5][5] + f[6][6] + f[5][6]= 

f[3][3] = 8
f[3][4] = a[3] + a[4] = 14
f[3][5] = a[3] + f[4][4] + f[5][5] + f[4][5] = 22
f[3][6] = a[3] + f[4][4] + f[5][5] + f[6][6] + f[4][6] = 26

f[2][2] = 6
f[2][3] = a[2] + a[3] = 14
f[2][4] = a[2] + f[3][3] + f[4][4] + f[3][4] = 30
f[2][5] = a[2] + f[3][3] + f[4][4] + f[5][5] + f[3][5] = 43
f[2][6] = a[2] + f[3][3] + f[4][4] + f[5][5] + f[6][6] + f[3][6] = 48

6 8 6 1 1 --> 6 8 6 2
6 8 6 2 --> 6 8 8
6 8 8 --> 14 8
14 8 --> 22


f[1][1] = 7
f[1][2] = a[1] + a[2] = 13
f[1][3] = a[1] + f[2][2] + f[3][3] + f[2][3] = 35
f[1][4] = a[1] + f[2][2] + f[3][3] + f[4][4] + f[2][4] = 57
f[1][5] = a[1] + f[2][2] + f[3][3] + f[4][4] + f[5][5] + f[2][5] = 
f[1][6] = 


- Gọi f[i][j] là chi phí nhỏ nhất để ghép các slime thứ i tới slime thứ j
- Bài toán cơ sở: f[0][0] = 0, f[i][j] = inf, f[i][i + 1] = a[i] + a[i + 1], f[i][i] = a[i]
- Đáp án bài toán: f[1][n]
- Công thức quy hoạch động: 
  .




   

  
 





















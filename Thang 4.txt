Tháng 4: Graph Theory cơ bản
  + Buổi 1: Introduce to Graph Theory + Dfs algorithm
  + Buổi 2: Topological Sortings
  + Buổi 3: Joints And Bridges
  + Buổi 4: Strongly Connected Component
  + Buổi 5: Bfs
  + Buổi 6: Dijkstra Algorithm
  + Buổi 7: Disjoint Set Union and Kruskal algorithm
  + Buổi 8: Contest

https://drive.google.com/drive/folders/1nlv28ZO7dPtjAo6gvN6YtXG2u18zkmf4?fbclid=IwAR1x944GFkEXnBnmfCvRBpm4nSXHoiPt7zdKgwZ45Eh5Q--pbs7WK1ScAus

https://drive.google.com/drive/folders/1VpA-M3VRloEarb6n157rNFsmdAuUFip6
--------------------------------------------------------------------------------------------------------------------------------------------------

Lý thuyết đồ thị

Đồ thị là gì ?????

Đồ thị là một tập hợp các đỉnh và cạnh, trong đó cạnh sẽ nối các đỉnh với nhau thể hiện mối quan hệ giữa 2 đỉnh. Một đỉnh có thể là một trạng thái

và cạnh thể hiện sự tương quan giữa 2 đỉnh với nhau.

Một số khái nhiệm cơ bản ta cần biết: 

1. Đỉnh: Là tập hợp các sự việc - sự vật - trạng thái được minh họa bằng những đỉnh. 

2. Cạnh: Thể hiện mối quan hệ giữa 2 đỉnh trong đồ thị với nhau. 1 cạnh chỉ nối giữa 2 đỉnh
   + Cạnh vô hướng: Là cạnh khi nối giữa 2 đỉnh u - v thì u có thể đến được v và ngược lại.
   + Cạnh có hướng: Là cạnh khi nối u -> v thì u có thể đến được v nhưng không có chiều ngược lại. 

3. Đường đi: Là một danh sách các đỉnh x1, x2, x3, ..., xk, trong đó 2 đỉnh kề xi và xi + 1 có cạnh nối trực tiếp với nhau và xi có thể sang xi+1

4. Trọng số: Là một con số được thể hiện trên một cạnh của đồ thị nhằm thể hiện một giá trị nào đó được quy định

--------------------------------------------------------------------------------------------------------------------------------------------------


						   BUỔI 1
						Thuật toán Dfs: 

Bài toán Dfs:

Cho một đồ thị gồm V đỉnh, E cạnh. Cho một đỉnh xuất phát là đỉnh start, hỏi từ đỉnh start có thể đến được những đỉnh nào ???????

Ý tưởng: 

Xuất phát tại đỉnh start, ta xét tất cả các đỉnh có thể đi được. Nếu đỉnh đó chưa được "thăm" thì hãy đến đỉnh đó.

Ban đầu: 

Ta tạo một mảng visited với ý nghĩa: 

visited[u] = true nếu u đã được "thăm", false nếu u chưa được "thăm"

Danh sách kề: 

Hãy tạo ra V cái kho, kho thứ u lưu trữ những đỉnh v kề với u.

khai báo: 

vector <int> adj[100005];

Dòng 1: Gồm 3 số N và M và đỉnh start

M dòng sau, mỗi dòng chứa 2 số u v với ý nghĩa có cạnh nối từ u -> v

Đọc số N và M

for i: 1 -> M
  đọc u v
  adj[u].push_back(v); // thêm được cạnh u -> v


Thiết kế hàm dfs(u): thể hiện ta đang đứng tại đỉnh u

dfs(u): 
  visited[u] = true
  for i: 0 -> (int) adj[u].size(); i++
     đặt v = adj[u][i] 
     nếu visited[v] == false
        dfs(v)

Độ phức tạp: O(V + E)

DfsAlgorithm:

#include <iostream> 
#include <vector>
std::vector <int> adj[100005]; 		// mảng 1 chiều, mỗi phần tử là 1 vector
int V, E, start;
bool visited[100005]; 

void dfs(int u) {
  visited[u] = true;
  for (int i = 0; i < (int) adj[u].size(); i++) {
    int v = adj[u][i];
    if (visited[v] == false) {
      dfs(v);
    }
  }
}

int main () {
  std::cin >> V >> E >> start;
  for (int i = 1; i <= E; i++) {
    int u, v;
    std::cin >> u >> v;
    adj[u].push_back(v);
  }
  dfs(start);
  for (int i = 1; i <= V; i++) {
    if (visited[i] == true) {
      std::cout << i << ' ';
    }
  }
  return 0; 
}

				------------------------------------------------------------------

Couting Rooms: https://cses.fi/problemset/task/1192/

Xem những ô trên bảng như 1 đỉnh của đồ thị

1 ô trên bảng được minh họa bằng 1 cặp tọa độ (x, y)

(x, y) kề với (x', y') khi nào ?????

Khi (x', y') thuộc 1 trong 4 trường hợp sau: 

(x', y') = (x + 1, y)
           (x, y + 1)
           (x - 1, y)
 	   (x, y - 1)

(x, y) sẽ kề với (x + dx[i], y + dy[i])

i = 0: (x, y) kề với (x, y + 1)
i = 1: (x, y) kề với (x, y - 1)


Gọi visited[x][y] = true nếu ô (x, y) đã thăm, = false trong tình huống ngược lại.
Viết hàm dfs(x, y): Ta đang đứng tại ô (x, y)

đặt 2 bảng: 
 dx[4] = {0, 0, 1, -1}
 dx[4] = {1, -1, 0, 0}

dfs(x, y)
  visited[x][y] = true
   for i: 0 -> 3
      đặt x' = x + dx[i] 
      đặt y' = y + dy[i]
      nếu 1 <= x' <= N và 1 <= y' <= M và ô (x', y') == '.' và visited[x'][y'] = false
        dfs(x',y')
Trong hàm main():
  for x: 1 -> n
     for y: 1 -> m
       nếu ô(x, y) == '.' và visited[x][y] == false:
          room++;
          dfs(x,y)


	Lời giải: 

#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
bool visited[1006][1006];
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
void dfs(int x, int y, char a[1005][1005], int d, int e) {
	visited[x][y] = true;
	for (int i = 0; i < 4; i++) {
		int X = x + dx[i];   // xét các vị trí xung quanh ô (x, y)
		int Y = y + dy[i];   // xét các vị trí xung quanh ô (x, y)
		if (X >= 1 && X <= d && Y >= 1 && Y <= e && a[X][Y] == '.' && visited[X][Y] == false) {
			dfs(X, Y, a, d, e);
		}
	}
}


int main () { 
	int n, m;
	cin >> n >> m;
	char c[1005][1005];
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> c[i][j];
		}
	}
	int room = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (c[i][j] == '.' && visited[i][j] == false) {
				room++;
				dfs(i, j, c, n, m);
			}
		}
	}
	cout << room << endl;
	return 0;
}



				------------------------------------------------------------------

Makemaze: https://www.spoj.com/problems/MAKEMAZE/

Cho một mê cung. Một ô(i, j) = '.' nếu ô (i, j) là khoảng trống, = '#' nếu ô (i, j) là tường

Cần kiểm tra mê cung này có hợp lệ hay không ? 

1 mê cung hợp lệ như sau: 

Nếu mê cung này có đúng 1 lối vào và 1 lối ra và từ lối vào có thể thông đến lối ra

Lối vào và lối ra phải nằm trên cạnh của mê cung

########
#......#
......##
#####.##
#####.##
#####.##


Gọi visited[x][y] = true nếu đã thăm ô (x, y) rồi, = false nếu chưa thăm

tọa độ các đường biên: (1, y: 1->n)
                       (m, y: 1->n)
                       (x: 1->m, 1)
	               (x: 1->m, n)
nếu số '.' trên các đường biên khác 2 ---> cout << "invalid" << endl;
 
nếu số '.' trên các đường biên == 2 thì xét dfs tại 1 điểm rồi xem visited ở điểm còn lại có == true ko 
   nếu == true --> cout << "valid" << endl;
    nếu không --> cout << "invalid" << endl;

 	Lời giải: 

#include <iostream>
#include <vector>
#include <utility>
#include <string>
using namespace std;

int numTest;
int m, n;
char c[22][22];
bool visited[22][22];
vector < pair <int, int> > index;
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
void dfs (int x, int y) {
	visited[x][y] = true;
	for (int i = 0; i < 4; i++) {
		int X = x + dx[i];
		int Y = y + dy[i];
		if (X >= 0 && X < m && Y >= 0 && Y < n && c[X][Y] == '.' && visited[X][Y] == false) {
			dfs(X, Y);
		}
	}
}

int main() {
	
	cin >> numTest;
	while (numTest--) {
		cin >> m >> n;
		index.clear();
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				cin >> c[i][j];
			}
		}	
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				visited[i][j] = false;
			}
		}
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {
					if (c[i][j] == '.') {
						index.push_back(make_pair(i, j));
					}
				}
			}
		}
		if ((int)index.size() != 2) {
			cout << "invalid" << endl;
			continue;
		}
		dfs(index[0].first, index[0].second);
		if (visited[index[1].first][index[1].second] == true) {
			cout << "valid" << endl;
		} else {
			cout << "invalid" << endl;
		}
	}

	return 0;
}



				------------------------------------------------------------------

Round Trip II: https://cses.fi/problemset/task/1678

Cho một đồ thị có hướng (những cạnh u -> v phải là cạnh có hướng). Một đồ thị DAG (Directed Acyclic Graph) là một đồ thị có hướng và có tồn tại

chu trình. 

*** Chu trình: Nếu ta xuất phát tại 1 đỉnh u, sau khi đi qua một số đỉnh và có thể quay lại u

Hỏi: Đồ thị đề cho có tồn tại chu trình hay không ? 

Nếu không: In ra No

Nếu có: in ra Yes và xuất 1 chu trình nào đó trong đồ thị.

ví dụ: 
4 5
1 3
2 1
2 4
3 2
3 4

--> 4
    2 1 3 2  // 2 tới 1, 1 tới 3, 3 quay lại về 2

    1 3 2 1
  

Gọi state[u] là trạng thái của đỉnh u 

0: u chưa được thăm
1: u đã được thăm và vẫn đang trong quá trình gọi dfs
2: u đã được thăm và nếu ta tiếp tục đi vào u, ta sẽ không tìm ra được chu trình

Tạo bảng trace[u] với ý nghĩa: Để đến được u, ta phải đến được trace[u] !!!!!

dfs(u): 
  state[u] = 1
  for mọi v kề với u
     nếu state[v] = 0
        trace[v] = u
         dfs(v)
     else nếu state[v] == 1
        XUẤT KẾT QUẢ(v, u)
        exit(0)
   state[u] = 2

XUẤT KẾT QUẢ(): 
  xuất v
  while true
     xuất u 
     u = trace[u]
     nếu u == v: dừng
  xuất v

int main () {
  for u: 1 -> n
     nếu state[u] == 0;
       dfs(u)
  cout << "IMPOSSIBLE" << endl;
}

	Giải tay: 
/*
state[1] = 1
  for i: 0 -> adj[1].size
     i = 0: 
      adj[1][0] = 3
      if (state[3] == 0) {
      	trace[3] = 1;
      	dfs(3)
      	   state[3] = 1
      	       for i: 0 -> adj[3].size
      	          i = 0
      	           adj[3].[0] = 2
      	             if (state[2] == 0) 
      	                trace[2] = 3
      	                dfs(2)
      	                   state[2] = 1
      	                      for i: 0 -> adj[2].size
      	                        i = 0
      	                           adj[2].[0] = 1
      	                              if (state[1] == 1)
      	                                 output(u = 2, v = 1)
	}
*/

	Lời giải: 


#include <iostream>
#include <vector>
using namespace std;
int n, m;
vector <int> adj[100005];
int state[100005];
int trace[100005];

void output(int u, int v) {
	vector <int> ans;
	ans.push_back(v);
	while (u != v) {
		ans.push_back(u);
		u = trace[u];
	}
	cout << (int)ans.size() + 1 << endl;
	cout << v << ' ';
	for (int i = (int)ans.size() - 1; i >= 0; i--) {
		cout << ans[i] << ' ';
	}
}

void dfs (int u) {
	state[u] = 1;
	for (int i = 0; i < (int)adj[u].size(); i++) {
		int v = adj[u][i];
		if (state[v] == 0) {
			trace[v] = u;
			dfs(v);
		} else if (state[v] == 1) {
			output(u, v);
			exit(0);			// de exit(1) thi bi Runtime error :)))
		}
	}
	state[u] = 2;
}

int main () { 	
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		adj[u].push_back(v);
	}
	for (int u = 1; u <= n; u++) {
		if (state[u] == 0) {
			dfs(u);
		}
	}
	cout << "IMPOSSIBLE" << endl;
	return 0;
}


				------------------------------------------------------------------

SC5: https://drive.google.com/drive/folders/1GmAttdleRKi7ToLEUpqb8cmmQS6xWjYN

	Lời giải: 


#include <iostream>
#include <vector>
#include <stdlib.h>
using namespace std;
int numTest;
int n, m;
string a[25];
bool visited[22][22][12];
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

void dfs (int x, int y, int pois) {
	visited[x][y][pois] = true;
	for (int i = 0; i < 4; i++) {
		int X = x + dx[i];
		int Y = y + dy[i];
		if (X >= 0 && X < n && Y >= 0 && Y < m && a[X][Y] != '#') {
			int Pois = pois;
			if (a[X][Y] >= '1' && a[X][Y] <= '9') {
				Pois += a[X][Y] - '0';
			} else if (a[X][Y] == 'S') {
				Pois = 0;
			}
			if (Pois >= 10) {
				continue;
			}
			if (visited[X][Y][Pois] == false) {
				dfs(X, Y, Pois);
			}
		}
	}
}

int main () { 	
	cin >> numTest;
	for (int TestCase = 1; TestCase <= numTest; TestCase++) {
		cin >> n >> m;
		for (int i = 0; i < n; i++) {
			cin >> a[i];
		}
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				for (int pois = 0; pois <= 9; pois++) {
					visited[i][j][pois] = false;
				}
			}
		}
		dfs(0, 0, 0);
		bool ans = false;
		for (int i = 0; i <= 9; i++) {
			if (visited[n - 1][m - 1][i] == true) {
				ans = true;
				break;
			}
		}
		cout << (ans == true ? "possible" : "impossible") << endl; 
	}	
	return 0;
}


--------------------------------------------------------------------------------------------------------------------------------------------------

						
					BUỔI 2

				Topological Sortings


Course Schedule: https://cses.fi/problemset/task/1679

Có N công việc đánh số từ 1 -> N. Ta sẽ có M yêu cầu trong công việc, trong đó yêu cầu thứ i gồm 2 công việc ui và vi với ý nghĩa: Để hoàn thành

công việc vi, ta phải hoàn thành được công việc ui trước.

Hỏi: Liệu có tồn tại 1 cách làm việc sao cho khi ta thực hiện TUẦN TỰ thì thỏa mãn toàn bộ các yêu cầu đưa ra.

Nếu không tồn tại, in ra IMPOSSIBLE 

stack <int> topo;

dfs(u): 
  visited[u] = true
  for mọi v kề với u:
       nếu visited[v] = false
          dfs(v)
  topo.push(u)

main():
 for u: 1 -> n
     nếu visited[u] == false
         dfs(u)
 xuất ra các đỉnh trong topo


	Lời giải: 

#include <iostream>
#include <vector>
#include <stdlib.h>
#include <stack>
using namespace std;
int n, m;
vector <int> adj[100005];
int state[100005];
int trace[100005];
stack <int> schedule;
bool visited[100005];

bool DAG (int u) {   //kiem tra xem co chu trinh hay ko 
	state[u] = 1;
	for (int i = 0; i < (int)adj[u].size(); i++) {
		int v = adj[u][i];
		if (state[v] == 0) {
			trace[v] = u;
			DAG(v);
		} else if (state[v] == 1) {
			return true;
			exit(0);
		}
	}
	state[u] = 2;
	return false;
}

void dfs (int u) {			//topo sortings
	visited[u] = true;
	for (int i = 0; i < (int)adj[u].size(); i++) {
		int v = adj[u][i];
		if (visited[v] == false) {
			dfs(v);
		}
	}
	schedule.push(u);
}
  				
int main () { 	
	cin >> n >> m;
	int u, v;
	for (int i = 1; i <= m; i++) {
		
		cin >> u >> v;
		adj[u].push_back(v);
	}
	for (int i = 1; i <= n; i++) {
		if (state[i] == 0) {
			DAG(i);
		}
	}
	for (int i = 1; i <= n; i++) {
		if (DAG(i) == true) {
			cout << "IMPOSSIBLE" << endl;
			return 0;
		}
	}
	for (int i = 1; i <= n; i++) {
		if (visited[i] == false) {
			dfs(i);
		}
	}
	while (schedule.empty() == false) {
		cout << schedule.top() << ' ';
		schedule.pop();
	}
	return 0;
}

					------------------------------------------------------------------

Build a Matrix With Conditions: https://leetcode.com/problems/build-a-matrix-with-conditions/

k = 5

[4, 1, 3, 2, 5] row

[3, 2, 5, 1, 4] col

[0  0  0  0  4
 0  0  0  1  0
 3  0  0  0  0
 0  2  0  0  0
 0  0  5  0  0]

	Lời giải: 

class Solution {
public:
    bool DAG (int u, vector <int> &state, const vector <vector<int>> &adj) {      //kiem tra co chu trinh hay khong
        state[u] = 1;
        for (int i = 0; i < (int)adj[u].size(); i++) {
            int v = adj[u][i];
            if (state[v] == 0) {
                if (DAG(v, state, adj) == true) {
                    return true;
                }
            } else if (state[v] == 1) {
                return true;
            }
        }
        state[u] = 2;
        return false;
    }

    void dfs (int u, vector <bool> &visited, stack <int> &store, const vector <vector <int>> &adj) {  //topo sorting
        visited[u] = true;
        for (int i = 0; i < (int)adj[u].size(); i++) {
            int v = adj[u][i];
            if (visited[v] == false) {
                dfs(v, visited, store, adj);
            } 
        }
        store.push(u);
    }

    vector <int> process(const vector <vector<int>> &adj) {         // nhu la ham main khi code binh thuong
        vector <int> ret;
        vector <int> state;
        vector <bool> visited;
        stack <int> store;
        int k = (int)adj.size();
        state.resize(k, 0);  // khai bao tat ca cac phan tu trong state dang == 0
        visited.resize(k, false); // khai bao tat ca cac phan tu trong visited dang == false
        for (int u = 0; u < k; u++) {
            if (state[u] == 0) {
                if (DAG(u, state, adj) == true) {  // neu co chu trinh thi dung chuong trinh
                    return ret;
                }
            }
        }

        for (int u = 0; u < k; u++) {
            if (visited[u] == false) {
                dfs(u, visited, store, adj);
            }
        }

        while (store.empty() == false) {
            int u = store.top();
            store.pop();
            ret.push_back(u);
        }
        return ret;
    }
    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {
        vector <vector <int>> ans;
        vector <vector <int>> adj;
        adj.resize(k);
        for (int i = 0; i < (int)rowConditions.size(); i++) {
            int above = rowConditions[i][0] - 1;
            int below = rowConditions[i][1] - 1;
            adj[above].push_back(below); // adj[0].push_back[1], adj[2].push_back[1]
        }
        vector <int> row = process(adj);
        if (row.empty() == true) {
            return ans;
        } // false --> row = [2, 1, 0]
        for (int i = 0; i < k; i++) {
            adj[i].clear();
        }
        for (int i = 0; i < (int)colConditions.size(); i++) {
            int left = colConditions[i][0] - 1;
            int right = colConditions[i][1] - 1;
            adj[left].push_back(right);  // adj[1].push_back(0), adj[2].push_back(1)
        }
        vector <int> col = process(adj);
        if (col.empty() == true) {
            return ans;
        } // false --> col = [2, 0, 1]
        for (int i = 0; i < k; i++) {       // gan tat ca cac phan tru trong ans == 0
            vector <int> v;
            for (int j = 0; j < k; j++) {
                v.push_back(0);       
            }
            ans.push_back(v);
        }
        vector <int> ansRow, ansCol;
        ansRow.resize(k, 0);
        ansCol.resize(k, 0);
        for (int i = 0; i < k; i++) {
            ansRow[row[i]] = i; // ansRow[2] = 0, ansRow[1] = 1, ansRow[0] = 2
        }
        for (int i = 0; i < k; i++) {
            ansCol[col[i]] = i; //ansCol[2] = 0, ansCol[0] = 1, ansCol[1] = 2
        }
        for (int i = 0; i < k; i++) {
            ans[ansRow[i]][ansCol[i]] = i + 1;  // ans[2][1] = 1, ans[1][2] = 2, ans[0][0] = 3
        }
        return ans;
    }
};


					------------------------------------------------------------------

Longest Path: https://atcoder.jp/contests/dp/tasks/dp_g


Cho một đồ thị có hướng gồm N đỉnh và M cạnh. Input đề bài bảo đảm đây là đồ thị không có chu trình

Hỏi độ dài đường đi dài nhất là bao nhiêu ??????????

vi du: 
4 5
1 2
1 3
3 2
2 4
3 4

--> 3  (1 3 2 4)

- Gọi f[u] là độ dài đường đi dài nhất khi ta kết thúc tại u
- Bài toán cơ sở: f[u] = 0
- Đáp án bài toán: for i: 1 -> n { ans = max(ans, f[i])}
- Công thức quy hoạch động: Nếu ta có đỉnh v kề với u,  f[u] = max(f[u], f[v] + 1)

Nguyên tắc của quy hoạch động: 

f[lớn] phải tính dựa trên lời giải đã có của f[nhỏ]


Ta đưa ra thứ tự topo

Xét i: 1 -> n
 đặt u = topo[i]
  duyệt mọi đỉnh v kề với u
   f[v] = max(f[v], f[u] + 1)

	Lời giải: 
#include <iostream>
#include <vector>
#include <stdlib.h>
#include <stack>
using namespace std;
int n, m;
int f[100005];
int visited[100005];
vector <int> adj[100005];
stack <int> store;

void dfs(int u) {
	visited[u] = true;
	for (int i = 0; i < (int)adj[u].size(); i++) {
		int v = adj[u][i];
		if (visited[v] == false) {
			dfs(v);
		}
	}
	store.push(u);	
}					// store = {4, 2, 3, 1}

int main () { 	
	cin >> n >> m;
	int u, v;
	for (int i = 1; i <= m; i++) {
		cin >> u >> v;
		adj[u].push_back(v);
	}
	for (int i = 1; i <= n; i++) {
		if (visited[i] == false) {
			dfs(i);
		}
	}
	
	while (!store.empty()) {
		int x = store.top();
		store.pop();
		for (int j = 0; j < (int)adj[x].size(); j++) {
			int y = adj[x][j];
			f[y] = max(f[y], f[x] + 1);
		}
	}
	/*
	x = 1
        for j: 0-> adj[1].size
            adj[1][0] = 2
            f[2] = max(f[2], f[1] + 1) = 1
            adj[1][1] = 3
            f[3] = max(f[3], f[1] + 1) = 1
	x = 3
            adj[3][0] = 2
            f[2] = max(f[2], f[3] + 1) = 2
            adj[3][1] = 4
            f[4] = max(f[4], f[3] + 1) = 2
        x = 2
            adj[2][0] = 4
            f[4] = max(f[4], f[2] + 1) = 3
        x = 4
	*/
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		ans = max(ans, f[i]);
	}
	cout << ans << endl;
	return 0;
}



			
--------------------------------------------------------------------------------------------------------------------------------------------------


						BUỔI 3

				Tìm khớp và cầu (Joints And Bridges)

Bài toán đặt ra: 

Cho một đồ thị G vô hướng gồm V đỉnh và E cạnh. Hãy xác định những cạnh trên đồ thị được gọi là "cầu" và những đỉnh trên đồ thị được gọi là "khớp"

Một cạnh được gọi là "cầu" nếu sau khi xóa cạnh này, đồ thị sẽ được chia thành nhiều thành phần liên thông hơn

Một đỉnh được gòi là "khớp" nếu sau khi xóa đỉnh này, đồ thị được sẽ chia thành nhiều thành phần liên thông hơn


					--------------------------------------------------------

Thuật toán Tarjan

Ta định nghĩa 2 bảng numb[u] và low[u] với ý nghĩa như sau: 

numb[u] là thứ tự duyệt dfs khi ta đứng tại đỉnh u 

low[u] là giá trị numb nhỏ nhất có thể mà ta có thể đạt được khi đứng tại u

					--------------------------------------------------------


 - Ta gọi từ u sang v là "cầu" nếu như numb[v] = low[v]
 - Ta có từ u sang v nếu u được gọi là "khớp" nếu low[v] >= numb[u] (riêng trường hợp khi u là start phải xét riêng, nếu số lượng đỉnh con của 
start > 1 thì start sẽ là "khớp")


					--------------------------------------------------------	

Graph: https://oj.vnoi.info/problem/graph_


	Lời giải 
#include <iostream> 
#include <vector>
#include <math.h>  
int n, m; 
std::vector <int> adj[10005]; 
int low[10005], numb[10005]; 
bool check[10005];  				// neu check[u] = true thi u la khop
bool visited[10005]; 
int timeDFS = 0, bridge = 0; 			// timeDFS la thu tu dfs

void dfs(int u, int father) {
  int child = 0; 				// child la dinh con
  low[u] = numb[u] = ++timeDFS; 
  visited[u] = true; 
  for (int i = 0; i < (int) adj[u].size(); i++) { 	// duyet cac dinh ke vs u
    int v = adj[u][i]; 
    if (v == father) {    				// father la dinh di truoc dinh child
      continue; 
    }
    if (visited[v] == false) {
      dfs(v, u);    					// sau khi duyet dfs cua dinh v thi se cho ra low[v]     
      low[u] = std::min(low[u], low[v]); 
      if (low[v] == numb[v]) {
        bridge++; 					// so luong cau se duoc tang len neu low[v] = numb[v]
      }
      child++; 					// trong qua trinh dfs(v) khi gap 1 dinh v chua duoc tham thi dinh child duoc tang len
      if (father == -1) { 				// day la tinh huong duyet dinh start
        if (child > 1) {
          check[u] = true; 
        }
      } // end truong hop duyet dinh start
      else if (low[v] >= numb[u]) {
        check[u] = true; 
      }
    }
    else { 					// truong hop dinh v da duoc visited
      low[u] = std::min(low[u], numb[v]); 
    }
  } 						// end duyet cac dinh ke vs u 
} 					// end dfs

int main () {
  std::cin >> n >> m; 
  for (int i = 1; i <= m; i++) {
    int u, v; 
    std::cin >> u >> v; 
    adj[u].push_back(v); 
    adj[v].push_back(u); 
  }
  for (int i = 1; i <= n; i++) {
    if (visited[i] == false) {
      dfs(i, -1); 
    }
  }
  int cntJoint = 0; // so luong khop
  for (int i = 1; i <= n; i++) {
    if (check[i] == true) {
      cntJoint++; 
    }
  }
  std::cout << cntJoint << " " << bridge; 
  return 0; 
}
					

					--------------------------------------------------------

Kbuild: https://oj.vnoi.info/problem/kbuild  (đồ thị dạng cây --> đồ thị vô hướng)

 - 1 cây có N đỉnh thì sẽ có (N - 1) cạnh ---> không tồn tại 1 chu trình
 - Tất cả các (N - 1) cạnh đều là "cầu" 


Ý tưởng bài toán: 

6
1 2
2 3
2 4
4 5
4 6
2
3 6
5 6
--> 1

có 2 ngày sửa cầu, ngày 1 là 3 6, ngày 2 là 5 6 thì ta sẽ nối cạnh từ 3 đến 6 để các cạnh 3 2 4 6 không còn là cầu, làm tương tự như v với 5 6

đáp án bài toán sẽ đếm số cầu trên đồ thị.

	Loi giai:
#include <iostream>
#include <vector>
#include <stdlib.h>
#include <stack>
#include <unordered_map>
using namespace std;
int n, m;
vector <int> adj[200005];
int timeDFS = 0, bridge = 0;
int low[200005], numb[200005];
unordered_map <int, bool> mymap[200005];

void countBridge(int u, int father) {
	numb[u] = low[u] = ++timeDFS;
	for (int i = 0; i < (int) adj[u].size(); i++) {
		int v = adj[u][i];
		if (v == father) {
			continue;
		}
		if (numb[v] == 0) {
			countBridge(v, u);
			low[u] = min(low[u], low[v]);
			if (low[v] == numb[v]) {
				if (mymap[u][v] == true) {
					continue;
				}
				bridge++;
			}
		} else {
			low[u] = min(low[u], numb[v]);
		}
	}
}

int main () {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	
	cin >> n;
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		adj[u].push_back(v);
		adj[v].push_back(u);		
	}
	cin >> m;
	for (int i = 1; i <= m; i++) {
		int a, b;
		cin >> a >> b;
		adj[a].push_back(b);
		adj[b].push_back(a);
		mymap[a][b] = true;  // nối từ a đến b
		mymap[b][a] = true;  // nối từ b đến a
	}
	
	countBridge(1, -1);
	
	cout << bridge << endl;
	return 0;
}


					--------------------------------------------------------

--------------------------------------------------------------------------------------------------------------------------------------------------

				
							BUỔI 4

				Strongly Connected Component (Thành phần liên thông mạnh)



Cho một đồ thị có hướng gồm V đỉnh, E cạnh. Một thành phần liên thông mạnh là 1 thành phần gồm tập hợp các đỉnh sao cho với 2 đỉnh u, v bất kì

trong thành phần liên thông đó, chúng có thể đến được với nhau.

Hỏi: Hãy liệt kê các thành phần liên thông mạnh đó.


Thuật toán Tarjan (được dùng trên cây DFS)

- Ta gọi numb[u] và low[u] với ý nghĩa: numb[u] là thứ tự duyệt dfs khi ta đứng tại đỉnh u, low[u] là thứ tự duyệt dfs nhỏ nhất trong những đỉnh

mà u có thể đến.

- Ta sử dụng 1 stack để lưu trữ tập hợp những đỉnh mà trong quá trình duyệt dfs. Nếu như đi vào một vùng liên thông mạnh, ta sẽ lấy các đỉnh

trong stack đó và những đỉnh đó là những đỉnh trong thành phần liên thông mạnh.


					--------------------------------------------------------

Tìm thành phần liên thông mạnh: https://oj.vnoi.info/problem/tjalg


- Gọi deleted[u] = true nếu đỉnh u đã được xóa
- Gọi store là 1 stack chứa danh sách các đỉnh được lưu: 
  dfs(u)
  timeDfs++
  low[u] = numb[u] = timeDfs
  store.push(u)
  for mọi v kề với u: 
      nếu deleted[v] == false
         nếu numb[v] == 0
           dfs(v)
           low[u] = min(low[u], low[v])
         else 
	   low[u] = min(low[u], numb[v])
 if (numb[u] = low[u]){
  while (true) {
    đặt v = store.top();
    deleted[v] = true;
    store.pop();
    nếu u == v: break
  }
 }

main () 
 for u: 1 -> n
   nếu numb[u] == 0 
    dfs(u)


			Lời giải: 

#include <iostream>
#include <vector>
#include <stdlib.h>
#include <stack>
using namespace std;
int n, m;
vector <int> adj[10005];
bool deleted[10005];
int numb[10005], low[10005], timeDfs = 0;
stack <int> store;
int countSC = 0;  // dem strongly component

void stronglyComponent (int u) {
	numb[u] = low[u] = ++timeDfs;
	store.push(u);
	for (int i = 0; i < (int) adj[u].size(); i++) {
		int v = adj[u][i];
		if (deleted[v] == false) {
			if (numb[v] == 0) {
				stronglyComponent(v);
				low[u] = min(low[u], low[v]);
			} else {
				low[u] = min(low[u], numb[v]);
			}
		}	
	}
	if (numb[u] == low[u]) {
		countSC++;
		while (true) {
			int v = store.top();
			store.pop();
			deleted[v] = true;
			if (u == v) {
				break;
			} 
		}		
	}
}

int main () {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		adj[u].push_back(v);
	}
	for (int i = 1; i <= n; i++) {
		if (numb[i] == 0) {
			stronglyComponent(i);
		}
	}
	cout << countSC << endl;
	return 0;
}	


--------------------------------------------------------------------------------------------------------------------------------------------------


							BUỔI 5

					Thuật toán BFS (Breadth First Search)

Cho một đồ thị gồm V đỉnh, E cạnh. Cho một đỉnh xuất phát start và 1 đỉnh kết thúc end. Hỏi độ dài đường đi ngắn nhất từ start đến end là bao

nhiêu. Độ dài của 1 đường đi là số lượng cạnh trên đường đi đó. (đồ thị có hướng hay vô hướng đều được)


Thuật toán Bfs: 

Tạo mảng dist[u] với ý nghĩa dist[u] là độ dài đường đi ngắn nhất từ start -> u

Ban đầu ta khởi tạo dist[u] = -1, dist[start] = 0

Tạo một hàng đợi Q để lưu trữ những đỉnh đang trong trạng thái được xét.

Khi ta đứng tại 1 đỉnh u, xét các đỉnh kề v, nếu dist[v] == -1 thì ta cập nhật dist[v] = dist[u] + 1 và đưa v vào hàng đợi

Giá trị dist của tất cả các đỉnh là độ dài đường đi ngắn nhất từ đỉnh start đến đỉnh đó. 


Mã giả: 

for u: 1 -> n: dist[u] = -1
Q: hàng đợi
dist[start] = 0
đưa start vào hàng đợi

while (Q khác rỗng): 
  lấy u ra khỏi hàng đợi
  xét mọi v kề với u
     nếu dist[v] == -1
      	dist[v] = dist[u] + 1
      	đưa v vào hàng đợi.	

Độ phức tạp: O(V + E)
 					
					--------------------------------------------------------

Move: https://oj.vnoi.info/problem/icpc22_mb_b

Cho 2 dãy số có số lượng phần tử bằng nhau là a và b gồm N phần tử.

Cho một con số s ban đầu và một con số M.

Sau mỗi bước thực hiện, ta có thể lấy s và thay đổi s = (s * a[i] + b[i]) % M

Hỏi sau tối thiểu bao nhiêu bước thì s = 0

Nếu không tồn tại bước để biến s thành 0 thì in ra -1

5 2 1 
a = [2, 3]
b = [1, 1]

s = 1

1 -> (1 * 2 + 1) % 5 = 3

3 -> (3 * 3 + 1) % 5 = 0


	Lời giải: 

#include <iostream>
#include <utility>
#include <vector>
#include <queue>
using namespace std;
int m, n, s0;
int dist[100000005];
queue <int> myqueue;
int a[13], b[12];

void bfs(int start) {
	for (int u = 0; u < m; u++) {
		dist[u] = -1;
	}
	dist[start] = 0;
	myqueue.push(start);
	while (!myqueue.empty()) {
		int u = myqueue.front();
		myqueue.pop();
		for (int i = 1; i <= n; i++) {
			long long v = (1LL * u * a[i] + b[i]) % m;   // yêu cầu đề bài
			if (dist[v] == -1) {
				dist[v] = dist[u] + 1;
				myqueue.push(v);
			}
		}
	}
}

int main () {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	
	cin >> m >> n >> s0;
	for (int i = 1; i <= n; i++) {
		cin >> a[i] >> b[i];
	}
	
	bfs(s0);
	
	cout << dist[0] << endl;
	
	return 0;
}

					--------------------------------------------------------

--------------------------------------------------------------------------------------------------------------------------------------------------

						

							BUỔI 6

					         Dijkstra Algorithm

Xét 1 đồ thị có hướng và có trọng số không âm G(V, E). Một cạnh từ u -> v có trọng số không âm w. Cho một đỉnh start, hỏi độ dài đường đi ngắn

nhất từ start đến tất cả các đỉnh còn lại.

Độ dài của một đường đi = tổng trọng số của các cạnh trên đường đi đó. (đồ thị có hướng hay vô hướng đều dùng được)


- Sử dụng ý tưởng tham lam (Greedy):

Với một đỉnh u (đã tìm được đường đi tối ưu từ start -> u). Xét mọi v kề với u, nếu đường đi đến v có thể được tối ưu dựa vô đường đi tới u thì ta

cập nhật

- Gọi dist[u] là độ dài đường đi ngắn nhất từ start đến u.

- Ta khởi tạo dist[u] = inf cho mọi u 

- Tạo một hàng đợi ưu tiên, mỗi phần tử là một cặp <distance, u> với ý nghĩa: Độ dài đường đi ngắn nhất đến u là distance

- Khi lấy u ra khỏi hàng đợi ưu tiên, xét mọi v kề với u. Nếu dist[v] > dist[u] + w(u, v) thì ta cập nhật dist[v] = dist[u] + w(u, v)
  và đưa cặp <dist[v], v> vào hàng đợi ưu tiên.
- Thực hiện đến khi hàng đợi ưu tiên rỗng.

Demo Dijkstra Algorithm: 


#include <iostream>
#include <utility>
#include <vector>
#include <queue>
#include <functional>
using namespace std;
const long long inf = 100000007LL;
long long dist[100005];
vector <pair <int, int>> adj[100005];
priority_queue <pair <long long, int>, vector <pair <long long, int> >, greater <pair <long long, int> > > pq;
int n, m, start;

void dijkstra (const int &start) {
	for (int i = 1; i <= n; i++) {
		dist[i] = inf;
	}
	dist[start] = 0;
	pq.push(make_pair(0, start));
	while (!pq.empty()) {
		pair <long long, int> element = pq.top();
		pq.pop();
		int u = element.second;
		long long distance = element.first;
		if (dist[u] != distance) {
			continue;
		}
		for (int i = 0; i < (int)adj[u].size(); i++) {
			pair <int, int> neighbor = adj[u][i];
			if (dist[neighbor.first] > dist[u] + neighbor.second) {
				dist[neighbor.first] = dist[u] + neighbor.second;
				pq.push(make_pair(dist[neighbor.fist], neighbor.first));
			}
		}
	}
}

int main () {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	
	cin >> n >> m >> start;
	for (int i = 1; i <= m; i++) {
		int u, v, weight;
		adj[u].push_back(make_pair(v, weight));
	}
	dijkstra(start);
	return 0;
}

					--------------------------------------------------------

Shortest Routes I: https://cses.fi/problemset/task/1671

	Lời giải: 

#include <iostream>
#include <utility>
#include <vector>
#include <functional>
#include <queue>
using namespace std;
int n, m;
const long long inf = 1000000000000007LL;
vector <pair <int, int> > adj[200005];
long long dist[100005];
priority_queue <pair <long long, int>, vector <pair <long long, int> >, greater <pair <long long, int> > > pq;

void dijkstra(const int start) {
	for (int i = 1; i <= n; i++) {
		dist[i] = inf;
	}
	dist[start] = 0;
	pq.push(make_pair(dist[start], start));
	while (!pq.empty()) {
		pair <long long, int> element = pq.top();
		pq.pop();
		int u = element.second;
		long long distance = element.first;
		if (dist[u] != distance) {
			continue;
		}
		for (int i = 0; i < (int)adj[u].size(); i++) {
			pair <int, int> neighbor = adj[u][i];
			if (dist[neighbor.first] > dist[u] + neighbor.second) {
				dist[neighbor.first] = dist[u] + neighbor.second;
				pq.push(make_pair(dist[neighbor.first], neighbor.first));
			}
		}
	}
}

int main () {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int a, b, c;
		cin >> a >> b >> c;
		adj[a].push_back(make_pair(b, c));
	}	
	dijkstra(1);
	for (int i = 1; i <= n; i++) {
		cout << dist[i] << ' ';
	}
	return 0;
}

					--------------------------------------------------------




















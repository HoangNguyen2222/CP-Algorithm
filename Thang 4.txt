Tháng 4: Graph Theory cơ bản
  + Buổi 1: Introduce to Graph Theory + Dfs algorithm
  + Buổi 2: Topological Sortings
  + Buổi 3: Joints And Bridges
  + Buổi 4: Strongly Connected Component
  + Buổi 5: Bfs
  + Buổi 6: Dijkstra Algorithm
  + Buổi 7: Disjoint Set Union and Kruskal algorithm
  + Buổi 8: Contest

https://drive.google.com/drive/folders/1nlv28ZO7dPtjAo6gvN6YtXG2u18zkmf4?fbclid=IwAR1x944GFkEXnBnmfCvRBpm4nSXHoiPt7zdKgwZ45Eh5Q--pbs7WK1ScAus

https://drive.google.com/drive/folders/1VpA-M3VRloEarb6n157rNFsmdAuUFip6
--------------------------------------------------------------------------------------------------------------------------------------------------

Lý thuyết đồ thị

Đồ thị là gì ?????

Đồ thị là một tập hợp các đỉnh và cạnh, trong đó cạnh sẽ nối các đỉnh với nhau thể hiện mối quan hệ giữa 2 đỉnh. Một đỉnh có thể là một trạng thái

và cạnh thể hiện sự tương quan giữa 2 đỉnh với nhau.

Một số khái nhiệm cơ bản ta cần biết: 

1. Đỉnh: Là tập hợp các sự việc - sự vật - trạng thái được minh họa bằng những đỉnh. 

2. Cạnh: Thể hiện mối quan hệ giữa 2 đỉnh trong đồ thị với nhau. 1 cạnh chỉ nối giữa 2 đỉnh
   + Cạnh vô hướng: Là cạnh khi nối giữa 2 đỉnh u - v thì u có thể đến được v và ngược lại.
   + Cạnh có hướng: Là cạnh khi nối u -> v thì u có thể đến được v nhưng không có chiều ngược lại. 

3. Đường đi: Là một danh sách các đỉnh x1, x2, x3, ..., xk, trong đó 2 đỉnh kề xi và xi + 1 có cạnh nối trực tiếp với nhau và xi có thể sang xi+1

4. Trọng số: Là một con số được thể hiện trên một cạnh của đồ thị nhằm thể hiện một giá trị nào đó được quy định

--------------------------------------------------------------------------------------------------------------------------------------------------

Thuật toán Dfs: 

Bài toán Dfs:

Cho một đồ thị gồm V đỉnh, E cạnh. Cho một đỉnh xuất phát là đỉnh start, hỏi từ đỉnh start có thể đến được những đỉnh nào ???????

Ý tưởng: 

Xuất phát tại đỉnh start, ta xét tất cả các đỉnh có thể đi được. Nếu đỉnh đó chưa được "thăm" thì hãy đến đỉnh đó.

Ban đầu: 

Ta tạo một mảng visited với ý nghĩa: 

visited[u] = true nếu u đã được "thăm", false nếu u chưa được "thăm"

Danh sách kề: 

Hãy tạo ra V cái kho, kho thứ u lưu trữ những đỉnh v kề với u.

khai báo: 

vector <int> adj[100005];

Dòng 1: Gồm 3 số N và M và đỉnh start

M dòng sau, mỗi dòng chứa 2 số u v với ý nghĩa có cạnh nối từ u -> v

Đọc số N và M

for i: 1 -> M
  đọc u v
  adj[u].push_back(v); // thêm được cạnh u -> v


Thiết kế hàm dfs(u): thể hiện ta đang đứng tại đỉnh u

dfs(u): 
  visited[u] = true
  for i: 0 -> (int) adj[u].size(); i++
     đặt v = adj[u][i] 
     nếu visited[v] == false
        dfs(v)

Độ phức tạp: O(V + E)

DfsAlgorithm:

#include <iostream> 
#include <vector>
std::vector <int> adj[100005]; 		// mảng 1 chiều, mỗi phần tử là 1 vector
int V, E, start;
bool visited[100005]; 

void dfs(int u) {
  visited[u] = true;
  for (int i = 0; i < (int) adj[u].size(); i++) {
    int v = adj[u][i];
    if (visited[v] == false) {
      dfs(v);
    }
  }
}

int main () {
  std::cin >> V >> E >> start;
  for (int i = 1; i <= E; i++) {
    int u, v;
    std::cin >> u >> v;
    adj[u].push_back(v);
  }
  dfs(start);
  for (int i = 1; i <= V; i++) {
    if (visited[i] == true) {
      std::cout << i << ' ';
    }
  }
  return 0; 
}

				------------------------------------------------------------------

Couting Rooms: https://cses.fi/problemset/task/1192/

Xem những ô trên bảng như 1 đỉnh của đồ thị

1 ô trên bảng được minh họa bằng 1 cặp tọa độ (x, y)

(x, y) kề với (x', y') khi nào ?????

Khi (x', y') thuộc 1 trong 4 trường hợp sau: 

(x', y') = (x + 1, y)
           (x, y + 1)
           (x - 1, y)
 	   (x, y - 1)

(x, y) sẽ kề với (x + dx[i], y + dy[i])

i = 0: (x, y) kề với (x, y + 1)
i = 1: (x, y) kề với (x, y - 1)


Gọi visited[x][y] = true nếu ô (x, y) đã thăm, = false trong tình huống ngược lại.
Viết hàm dfs(x, y): Ta đang đứng tại ô (x, y)

đặt 2 bảng: 
 dx[4] = {0, 0, 1, -1}
 dx[4] = {1, -1, 0, 0}

dfs(x, y)
  visited[x][y] = true
   for i: 0 -> 3
      đặt x' = x + dx[i] 
      đặt y' = y + dy[i]
      nếu 1 <= x' <= N và 1 <= y' <= M và ô (x', y') == '.' và visited[x'][y'] = false
        dfs(x',y')
Trong hàm main():
  for x: 1 -> n
     for y: 1 -> m
       nếu ô(x, y) == '.' và visited[x][y] == false:
          room++;
          dfs(x,y)


	Lời giải: 

#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>
#include <vector>
#include <set>
#include <deque>
#include <utility>
#include <map>
#include <bitset>
#pragma GCC target("popcnt")
#include <stdbool.h>
#include <fstream>
#include <math.h>
#include <iomanip>
#include <cstring>
#include <string>
using namespace std;
bool visited[1006][1006];
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
void dfs(int x, int y, char a[1005][1005], int d, int e) {
	visited[x][y] = true;
	for (int i = 0; i < 4; i++) {
		int X = x + dx[i];   // xét các vị trí xung quanh ô (x, y)
		int Y = y + dy[i];   // xét các vị trí xung quanh ô (x, y)
		if (X >= 1 && X <= d && Y >= 1 && Y <= e && a[X][Y] == '.' && visited[X][Y] == false) {
			dfs(X, Y, a, d, e);
		}
	}
}


int main () { 
	int n, m;
	cin >> n >> m;
	char c[1005][1005];
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> c[i][j];
		}
	}
	int room = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (c[i][j] == '.' && visited[i][j] == false) {
				room++;
				dfs(i, j, c, n, m);
			}
		}
	}
	cout << room << endl;
	return 0;
}



				------------------------------------------------------------------

Makemaze: https://www.spoj.com/problems/MAKEMAZE/

Cho một mê cung. Một ô(i, j) = '.' nếu ô (i, j) là khoảng trống, = '#' nếu ô (i, j) là tường

Cần kiểm tra mê cung này có hợp lệ hay không ? 

1 mê cung hợp lệ như sau: 

Nếu mê cung này có đúng 1 lối vào và 1 lối ra và từ lối vào có thể thông đến lối ra

Lối vào và lối ra phải nằm trên cạnh của mê cung

########
#......#
......##
#####.##
#####.##
#####.##


Gọi visited[x][y] = true nếu đã thăm ô (x, y) rồi, = false nếu chưa thăm

tọa độ các đường biên: (1, y: 1->n)
                       (m, y: 1->n)
                       (x: 1->m, 1)
	               (x: 1->m, n)
nếu số '.' trên các đường biên khác 2 ---> cout << "invalid" << endl;
 
nếu số '.' trên các đường biên == 2 thì xét dfs tại 1 điểm rồi xem visited ở điểm còn lại có == true ko 
   nếu == true --> cout << "valid" << endl;
    nếu không --> cout << "invalid" << endl;

 	Lời giải: 

#include <iostream>
#include <vector>
#include <utility>
#include <string>
using namespace std;

int numTest;
int m, n;
char c[22][22];
bool visited[22][22];
vector < pair <int, int> > index;
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
void dfs (int x, int y) {
	visited[x][y] = true;
	for (int i = 0; i < 4; i++) {
		int X = x + dx[i];
		int Y = y + dy[i];
		if (X >= 0 && X < m && Y >= 0 && Y < n && c[X][Y] == '.' && visited[X][Y] == false) {
			dfs(X, Y);
		}
	}
}

int main() {
	
	cin >> numTest;
	while (numTest--) {
		cin >> m >> n;
		index.clear();
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				cin >> c[i][j];
			}
		}	
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				visited[i][j] = false;
			}
		}
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {
					if (c[i][j] == '.') {
						index.push_back(make_pair(i, j));
					}
				}
			}
		}
		if ((int)index.size() != 2) {
			cout << "invalid" << endl;
			continue;
		}
		dfs(index[0].first, index[0].second);
		if (visited[index[1].first][index[1].second] == true) {
			cout << "valid" << endl;
		} else {
			cout << "invalid" << endl;
		}
	}

	return 0;
}



				------------------------------------------------------------------

Round Trip II: https://cses.fi/problemset/task/1678

Cho một đồ thị có hướng (những cạnh u -> v phải là cạnh có hướng). Một đồ thị DAG (Directed Acyclic Graph) là một đồ thị có hướng và có tồn tại

chu trình. 

*** Chu trình: Nếu ta xuất phát tại 1 đỉnh u, sau khi đi qua một số đỉnh và có thể quay lại u

Hỏi: Đồ thị đề cho có tồn tại chu trình hay không ? 

Nếu không: In ra No

Nếu có: in ra Yes và xuất 1 chu trình nào đó trong đồ thị.

ví dụ: 
4 5
1 3
2 1
2 4
3 2
3 4

--> 4
    2 1 3 2  // 2 tới 1, 1 tới 3, 3 quay lại về 2

    1 3 2 1
  

Gọi state[u] là trạng thái của đỉnh u 

0: u chưa được thăm
1: u đã được thăm và vẫn đang trong quá trình gọi dfs
2: u đã được thăm và nếu ta tiếp tục đi vào u, ta sẽ không tìm ra được chu trình

Tạo bảng trace[u] với ý nghĩa: Để đến được u, ta phải đến được trace[u] !!!!!

dfs(u): 
  state[u] = 1
  for mọi v kề với u
     nếu state[v] = 0
        trace[v] = u
         dfs(v)
     else nếu state[v] == 1
        XUẤT KẾT QUẢ(v, u)
        exit(0)
   state[u] = 2

XUẤT KẾT QUẢ(): 
  xuất v
  while true
     xuất u 
     u = trace[u]
     nếu u == v: dừng
  xuất v

int main () {
  for u: 1 -> n
     nếu state[u] == 0;
       dfs(u)
  cout << "IMPOSSIBLE" << endl;
}

	Giải tay: 
/*
state[1] = 1
  for i: 0 -> adj[1].size
     i = 0: 
      adj[1][0] = 3
      if (state[3] == 0) {
      	trace[3] = 1;
      	dfs(3)
      	   state[3] = 1
      	       for i: 0 -> adj[3].size
      	          i = 0
      	           adj[3].[0] = 2
      	             if (state[2] == 0) 
      	                trace[2] = 3
      	                dfs(2)
      	                   state[2] = 1
      	                      for i: 0 -> adj[2].size
      	                        i = 0
      	                           adj[2].[0] = 1
      	                              if (state[1] == 1)
      	                                 output(u = 2, v = 1)
	}
*/

	Lời giải: 


#include <iostream>
#include <vector>
using namespace std;
int n, m;
vector <int> adj[100005];
int state[100005];
int trace[100005];

void output(int u, int v) {
	vector <int> ans;
	ans.push_back(v);
	while (u != v) {
		ans.push_back(u);
		u = trace[u];
	}
	cout << (int)ans.size() + 1 << endl;
	cout << v << ' ';
	for (int i = (int)ans.size() - 1; i >= 0; i--) {
		cout << ans[i] << ' ';
	}
}

void dfs (int u) {
	state[u] = 1;
	for (int i = 0; i < (int)adj[u].size(); i++) {
		int v = adj[u][i];
		if (state[v] == 0) {
			trace[v] = u;
			dfs(v);
		} else if (state[v] == 1) {
			output(u, v);
			exit(0);			// de exit(1) thi bi Runtime error :)))
		}
	}
	state[u] = 2;
}

int main () { 	
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		adj[u].push_back(v);
	}
	for (int u = 1; u <= n; u++) {
		if (state[u] == 0) {
			dfs(u);
		}
	}
	cout << "IMPOSSIBLE" << endl;
	return 0;
}


				------------------------------------------------------------------

SC5: https://drive.google.com/drive/folders/1GmAttdleRKi7ToLEUpqb8cmmQS6xWjYN

	Lời giải: 


#include <iostream>
#include <vector>
#include <stdlib.h>
using namespace std;
int numTest;
int n, m;
string a[25];
bool visited[22][22][12];
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

void dfs (int x, int y, int pois) {
	visited[x][y][pois] = true;
	for (int i = 0; i < 4; i++) {
		int X = x + dx[i];
		int Y = y + dy[i];
		if (X >= 0 && X < n && Y >= 0 && Y < m && a[X][Y] != '#') {
			int Pois = pois;
			if (a[X][Y] >= '1' && a[X][Y] <= '9') {
				Pois += a[X][Y] - '0';
			} else if (a[X][Y] == 'S') {
				Pois = 0;
			}
			if (Pois >= 10) {
				continue;
			}
			if (visited[X][Y][Pois] == false) {
				dfs(X, Y, Pois);
			}
		}
	}
}

int main () { 	
	cin >> numTest;
	for (int TestCase = 1; TestCase <= numTest; TestCase++) {
		cin >> n >> m;
		for (int i = 0; i < n; i++) {
			cin >> a[i];
		}
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				for (int pois = 0; pois <= 9; pois++) {
					visited[i][j][pois] = false;
				}
			}
		}
		dfs(0, 0, 0);
		bool ans = false;
		for (int i = 0; i <= 9; i++) {
			if (visited[n - 1][m - 1][i] == true) {
				ans = true;
				break;
			}
		}
		cout << (ans == true ? "possible" : "impossible") << endl; 
	}	
	return 0;
}


--------------------------------------------------------------------------------------------------------------------------------------------------

						
					BUỔI 2

				Topological Sortings


Course Schedule: https://cses.fi/problemset/task/1679

Có N công việc đánh số từ 1 -> N. Ta sẽ có M yêu cầu trong công việc, trong đó yêu cầu thứ i gồm 2 công việc ui và vi với ý nghĩa: Để hoàn thành

công việc vi, ta phải hoàn thành được công việc ui trước.

Hỏi: Liệu có tồn tại 1 cách làm việc sao cho khi ta thực hiện TUẦN TỰ thì thỏa mãn toàn bộ các yêu cầu đưa ra.

Nếu không tồn tại, in ra IMPOSSIBLE 

stack <int> topo;

dfs(u): 
  visited[u] = true
  for mọi v kề với u:
       nếu visited[v] = false
          dfs(v)
  topo.push(u)

main():
 for u: 1 -> n
     nếu visited[u] == false
         dfs(u)
 xuất ra các đỉnh trong topo


	Lời giải: 

#include <iostream>
#include <vector>
#include <stdlib.h>
#include <stack>
using namespace std;
int n, m;
vector <int> adj[100005];
int state[100005];
int trace[100005];
stack <int> schedule;
bool visited[100005];

bool DAG (int u) {   //kiem tra xem co chu trinh hay ko 
	state[u] = 1;
	for (int i = 0; i < (int)adj[u].size(); i++) {
		int v = adj[u][i];
		if (state[v] == 0) {
			trace[v] = u;
			DAG(v);
		} else if (state[v] == 1) {
			return true;
			exit(0);
		}
	}
	state[u] = 2;
	return false;
}

void dfs (int u) {			//topo sortings
	visited[u] = true;
	for (int i = 0; i < (int)adj[u].size(); i++) {
		int v = adj[u][i];
		if (visited[v] == false) {
			dfs(v);
		}
	}
	schedule.push(u);
}

int main () { 	
	cin >> n >> m;
	int u, v;
	for (int i = 1; i <= m; i++) {
		
		cin >> u >> v;
		adj[u].push_back(v);
	}
	for (int i = 1; i <= n; i++) {
		if (state[i] == 0) {
			DAG(i);
		}
	}
	for (int i = 1; i <= n; i++) {
		if (DAG(i) == true) {
			cout << "IMPOSSIBLE" << endl;
			return 0;
		}
	}
	for (int i = 1; i <= n; i++) {
		if (visited[i] == false) {
			dfs(i);
		}
	}
	while (schedule.empty() == false) {
		cout << schedule.top() << ' ';
		schedule.pop();
	}
	return 0;
}

					------------------------------------------------------------------



				
--------------------------------------------------------------------------------------------------------------------------------------------------


						BUỔI 3

	Tìm khớp và cầu (Joints And Bridges)

Bài toán đặt ra: 

Cho một đồ thị G vô hướng gồm V đỉnh và E cạnh. Hãy xác định những cạnh trên đồ thị được gọi là "cầu" và những đỉnh trên đồ thị được gọi là "khớp"

Một cạnh được gọi là "cầu" 










